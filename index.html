<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>GiddyPoet</title>
  <meta name="author" content="GiddyPoet">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="GiddyPoet"/>

  
    <meta property="og:image" content=""/>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-70812759-1', 'auto');
  ga('send', 'pageview');
</script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?cb5448498d7169c668b07c2b255d62c1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


<meta name="generator" content="Hexo 6.0.0"></head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">GiddyPoet</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class=""></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class=""></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class=""></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class=""></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="page-header logo">
  <h1>GiddyPoet<span class="blink-fast">∎</span></h1>
</div>

<div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">


		<i class="fa fa-heart blink-slow"></i>

		Better to run than curse the road.

</div>    

		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/06/13/ip-range/" >ip_range</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-06-13  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h1 id="ip地址范围判断问题"><a href="#ip地址范围判断问题" class="headerlink" title="ip地址范围判断问题"></a>ip地址范围判断问题</h1><p>在实现场景中，时长遇到需要判断ip地址是否在范围内，或者ip地址是否在这个网段内，因此将简述ip地址判断问题，目前支持以下场景。</p>
<ul>
<li>ip1-ip2</li>
<li>ip&#x2F;CIDR (ip&#x2F;24)</li>
<li>ip&#x2F;netmask (ip&#x2F;255.255.255.0)</li>
</ul>
<h2 id="ip地址判断"><a href="#ip地址判断" class="headerlink" title="ip地址判断"></a>ip地址判断</h2><h3 id="ip地址格式"><a href="#ip地址格式" class="headerlink" title="ip地址格式"></a>ip地址格式</h3><p>常用的地址格式类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">short</span>    sa_family;    <span class="comment">// address family, AF_xxx</span></span><br><span class="line">   <span class="keyword">char</span>              sa_data[<span class="number">14</span>];  <span class="comment">// 14 bytes of protocol address</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">short</span>            sin_family;   <span class="comment">// e.g. AF_INET, AF_INET6</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>   sin_port;     <span class="comment">// e.g. htons(3490)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>   <span class="title">sin_addr</span>;</span>     <span class="comment">// see struct in_addr, below</span></span><br><span class="line">    <span class="keyword">char</span>             sin_zero[<span class="number">8</span>];  <span class="comment">// zero this if you want to</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line">    <span class="keyword">u_int16_t</span>       sin6_family;   <span class="comment">// address family, AF_INET6</span></span><br><span class="line">    <span class="keyword">u_int16_t</span>       sin6_port;     <span class="comment">// port number, Network Byte Order</span></span><br><span class="line">    <span class="keyword">u_int32_t</span>       sin6_flowinfo; <span class="comment">// IPv6 flow information</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>     <span class="comment">// IPv6 address</span></span><br><span class="line">    <span class="keyword">u_int32_t</span>       sin6_scope_id; <span class="comment">// Scope ID</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>  ss_family;     <span class="comment">// address family</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// all this is padding, implementation specific, ignore it:</span></span><br><span class="line">    <span class="keyword">char</span>      __ss_pad1[_SS_PAD1SIZE];</span><br><span class="line">    <span class="keyword">int64_t</span>   __ss_align;</span><br><span class="line">    <span class="keyword">char</span>      __ss_pad2[_SS_PAD2SIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>struct sockaddr</code> 通常不会自己创建，该结构体，一般都是通过<code>struct sockaddr_in</code>和<code>struct sockaddr_in6</code>进行转换，由于历史因素，因此套接字api都只支持<code>struct sockaddr</code>，通过family字段进行判断，同时支持ipv4和ipv6，如果一个ip地址是ipv4,它只会读取其前4个字节，如果是ipv6，则会读取完整的16个字节.s</li>
<li><code>struct sockaddr_in</code> ipv4地址格式</li>
<li><code>struct sockaddr_in6</code> ipv6地址格式</li>
<li><code>struct sockaddr_storage</code> 当你不知道地址类型具体是什么的时候可以使用该结构体，该结构体即支持ipv4也支持ipv6，该地址类型被设计的足够大可以支持<code>struct sockaddr_un</code></li>
</ul>
<blockquote>
<p>对于unix socket需要通过offsetof实现绑定，addrlen &#x3D; offsetof(struct sockaddr_un, sun_path) + strlen(un.sun_path); 需要制定具体的长度，上述地址格式一般都是历史遗留问题。</p>
</blockquote>
<h3 id="地址格式转换"><a href="#地址格式转换" class="headerlink" title="地址格式转换"></a>地址格式转换</h3><blockquote>
<p>从文件中读取ip地址，进行判断，通常这种配置都是通过点分形式通知，因此需要将ipstr转换成地址</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IPSTORAGE</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> is_ipv6;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">in_addr_t</span> ipv4;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">ipv6</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;IPSTORAGE;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISIPV6(str) (strchr(str,<span class="meta-string">&#x27;:&#x27;</span>)?true:false)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_legal_ip_addr</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[INET6_ADDRSTRLEN];</span><br><span class="line">    <span class="keyword">if</span>(ISIPV6(str)) &#123;</span><br><span class="line">        <span class="keyword">return</span> inet_pton(AF_INET6, str, buf) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> inet_pton(AF_INET, str, buf) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IPSTORAGE <span class="title">str2ipstorage</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    IPSTORAGE is;</span><br><span class="line">    <span class="keyword">if</span>(ISIPV6(str)) &#123;</span><br><span class="line">        is.is_ipv6 = <span class="literal">true</span>; </span><br><span class="line">        inet_pton(AF_INET6, str, &amp;is.ipv6);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        is.is_ipv6 = <span class="literal">false</span>;</span><br><span class="line">        inet_pton(AF_INET, str, &amp;is.ipv4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *f = fopen(<span class="string">&quot;./test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf, <span class="keyword">sizeof</span>(buf), f)!= <span class="literal">NULL</span>) &#123;</span><br><span class="line">        buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!is_legal_ip_addr(buf)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;illegal ip addr %s.\n&quot;</span>, buf);</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">continue</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ip addr %s\n&quot;</span>,buf);</span><br><span class="line"></span><br><span class="line">        IPSTORAGE is = str2ipstorage(buf);</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码就是常见的字符串转ip地址的常用场景，主要说明一下几点：</p>
<ol>
<li>为什么要自己定义IPSTORAGE，实际上就是便于处理ipv4和ipv6的兼容性，<code>struct sockaddr_storage</code>也能实现该功能，但是还是要借助<code>struct sockaddr_in</code>和<code>struct sockaddr_in6</code>，用union处理<code>in_addr_t</code>和<code>struct in6_addr</code>处理起来较为方便。</li>
<li>利用inet_pton检查ip格式的合法性，这个比较常见。</li>
</ol>
<h3 id="ip地址范围判定"><a href="#ip地址范围判定" class="headerlink" title="ip地址范围判定"></a>ip地址范围判定</h3><h4 id="ip1-ip2"><a href="#ip1-ip2" class="headerlink" title="ip1-ip2"></a>ip1-ip2</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ipstorage_lt</span><span class="params">(IPSTORAGE *is1, IPSTORAGE *is2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(is1-&gt;is_ipv6) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;is1-&gt;ipv6, &amp;is2-&gt;ipv6, <span class="keyword">sizeof</span>(struct in6_addr)) &lt; <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (is-&gt;ipv4) &lt; (is-&gt;ipv4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ipstorage_gt</span><span class="params">(IPSTORAGE *is1, IPSTORAGE *is2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !ipstorage_lt(is1,is2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ipstorage_between</span><span class="params">(IPSTORAGE *dst, IPSTORAGE *left, IPSTORAGE *right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dst-&gt;is_ipv6 != left-&gt;is_ipv6) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ipstorage_gt(dst, right) || ipstorage_lt(dst, left)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实ipv4地址基于网络字节序或者主机字节序做比较都可以，只是由现成将str转换成网络字节序的函数，直接用网络字节序比较方便<br>ipv6的地址比较直接比较内存大小就可以，ipv6是16个uint8做比较。</p>
</blockquote>
<h4 id="ip-x2F-CIDR或ip-x2F-netmask"><a href="#ip-x2F-CIDR或ip-x2F-netmask" class="headerlink" title="ip&#x2F;CIDR或ip&#x2F;netmask"></a>ip&#x2F;CIDR或ip&#x2F;netmask</h4><p>先做判断，只要判断”&#x2F;“后是不是地址，就可以区分CIDR或netmask。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_ipv4</span><span class="params">(<span class="keyword">char</span> *ip)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="keyword">return</span> inet_pton(AF_INET, ip, buf)? <span class="literal">true</span>: <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 255.255.255.0 = 1111 1111 1111 1111 1111 1111 0000 0000 位运算</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mask2prefix</span><span class="params">(struct in_addr addr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">uint32_t</span> saddr = ntohl(mask.s_addr);</span><br><span class="line">    <span class="keyword">for</span>(count = <span class="number">0</span>; saddr &gt; <span class="number">0</span>; count++) &#123;</span><br><span class="line">        saddr = saddr &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct in_addr <span class="title">prefix2mask</span><span class="params">(<span class="keyword">int</span> prefix)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">addr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(prefix) &#123;</span><br><span class="line">        addr.s_addr = htonl(~(<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - preix) <span class="number">-1</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        addr.s_addr = htonl(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_ipv6_host_in_route</span><span class="params">(IPSTORAGE *is1, <span class="keyword">int</span> prefix, IPSTORAGE *is2)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> *<span class="title">route</span> =</span> &amp;is1-&gt;ipv6;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> *<span class="title">host</span> =</span> &amp;is2-&gt;ipv6;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prefix是8的整数的每个uint8_t 做对比，剩下的不足一个字节的 前bit个位做对比</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> bits = prefix;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; bits &gt;= <span class="number">8</span>; i++, bits -=<span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(route-&gt;s6_addr[i] != host-&gt;s6_addr[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bits == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> mask = <span class="number">0xff</span> &lt;&lt;( <span class="number">8</span> - bits);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((route-&gt;s6_addr[i]&amp;mask) == (host-&gt;s6_addr[i] &amp; mask)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ipstorage_inside</span><span class="params">(IPSTORAGE *is1, <span class="keyword">int</span> prefix, IPSTORAGE *is2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(is1-&gt;is_ipv6 != is2-&gt;is_ipv6) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(is1-&gt;is_ipv6) &#123;</span><br><span class="line">        <span class="keyword">return</span> is_ipv6_host_in_route(is1, prefix, is2);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        struct in_addr in = prefix2mask(prefix);</span><br><span class="line">        <span class="keyword">uint32_t</span> mask = ntohl(in_addr.s_addr);</span><br><span class="line">        <span class="keyword">if</span>((is1-&gt;ipv4 &amp; mask) == (is2-&gt;ipv4 &amp; mask)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ptr = <span class="built_in">strchr</span>(str, <span class="string">&#x27;/&#x27;</span>)) &#123;</span><br><span class="line">    *ptr++ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> prefix;</span><br><span class="line">    <span class="keyword">if</span>((is_ipv4(ptr))) &#123;</span><br><span class="line">        <span class="comment">// netmask</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">maskaddr</span>;</span></span><br><span class="line">        maskaddr.s_addr = inet_addr(ptr);</span><br><span class="line">        prefix = mask2prefix(maskaddr);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// CIDR</span></span><br><span class="line">        prefix = atoi(ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IPSTORAGE is1 = str2ipstorage(buf);</span><br><span class="line">    IPSTORAGE is2 = str2ipstorage(dst_ip);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ipstrorage_inside(&amp;is1, prefix, &amp;is2)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ip in range.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际上上述的操作都是利用了两个特性</p>
<ol>
<li>ipv4地址实际上是一个uint32_t</li>
<li>ipv6地址实际上是一个uint8_t[16], 这样就不区分主机字节序或网络字节序了</li>
</ol>
</blockquote>
<ol>
<li>先获取到子网掩码</li>
<li>如果是ipv4的话就直接通过主机号做判断，地址1 &amp; 子网掩码 &#x3D;&#x3D; 地址2 &amp; 子网掩码</li>
<li>如果是ipv6的话就每一个字节进行判断，不足一个字节，取高bits，(is1-&gt;s6_addr[i] &amp; bits) &#x3D;&#x3D; (is2-&gt;s6_addr[i] &amp; bits)</li>
</ol>
<h5 id="ipv6不区分网络字节序相关验证"><a href="#ipv6不区分网络字节序相关验证" class="headerlink" title="ipv6不区分网络字节序相关验证"></a>ipv6不区分网络字节序相关验证</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str6 = <span class="string">&quot;fec1::02&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> prefix = <span class="number">64</span>; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">ipv6</span>;</span></span><br><span class="line"></span><br><span class="line">    inet_pton(AF_INET6, str6, &amp;ipv6); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; <span class="number">16</span> ;i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%x &quot;</span>, ipv6.s6_addr[i]);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;                                         </span><br></pre></td></tr></table></figure>


<h4 id="对于unix-socket的相关操作"><a href="#对于unix-socket的相关操作" class="headerlink" title="对于unix socket的相关操作"></a>对于unix socket的相关操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATH <span class="meta-string">&quot;/tmp/GiddyPoet&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">un</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">ss</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">socklen_t</span> len;</span><br><span class="line"></span><br><span class="line">    unlink(PATH);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;un ,<span class="number">0</span> , <span class="keyword">sizeof</span>(un));</span><br><span class="line">    un.sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strcpy</span>(un.sun_path, PATH);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> addrlen = offsetof(struct sockaddr_un, sun_path) + <span class="built_in">strlen</span>(PATH);</span><br><span class="line"></span><br><span class="line">    bind(fd, (struct sockaddr *)&amp;un, addrlen);</span><br><span class="line"></span><br><span class="line">    listen(fd, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> client_fd = accept(fd, (struct sockaddr *)&amp;ss, &amp;len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ss.ss_family == AF_UNIX) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;AF_UNIX.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(type, f) ((size_t) \</span></span><br><span class="line"><span class="meta">    ((char *)&amp;((type *)0)-&gt;f - (char *)(type *)0))</span></span><br></pre></td></tr></table></figure>

<p>简单介绍下<code>offsetof</code>，通过将起始地址为0的结构体中的f成员获取，f在结构体中的偏移量，然后转换成<code>char *</code>计算出具体偏移的字节数。</p>

	
	</div>
  <a type="button" href="/2022/06/13/ip-range/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/05/20/路由/" >路由</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-05-20  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		
	
	</div>
  <a type="button" href="/2022/05/20/路由/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/04/18/操作系统导论/" >操作系统导论</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-04-18  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h1 id="第一章-关于本书的对话"><a href="#第一章-关于本书的对话" class="headerlink" title="第一章 关于本书的对话"></a>第一章 关于本书的对话</h1><p>Operating Systems: Three Easy Pieces：</p>
<ul>
<li>虚拟化(virtualization)</li>
<li>并发(concurrency)</li>
<li>持久性(persistence)</li>
</ul>
<h1 id="第二章-操作系统介绍"><a href="#第二章-操作系统介绍" class="headerlink" title="第二章 操作系统介绍"></a>第二章 操作系统介绍</h1><p>程序运行时会发生什么：(冯诺依曼计算模型)<br>获取指令<code>fecth</code> -&gt; 解码指令<code>decode</code> -&gt; 执行指令<code>execute</code></p>
<p>操作系统主要利用一种通用的技术，我们称之为虚拟化（virtualization）。也就是说，操作系统将物理（physical）资源（如处理器、内存或磁盘）转换为更通用、更强大且更易于使用的虚拟形式。</p>
<p>为了让用户可以告诉操作系统做什么，从而利用虚拟机的功能（如运行程序、分配内存或访问文件），操作系统还提供了一些接口（API）。</p>
<blockquote>
<p>总的来说操作系统对下屏蔽底层硬件细节，对上提供接口调用底层硬件。让程序运行变得容易（甚至允许你同时运行多个程序），允许程序共享内存，让程序能够与设备交互，以及其他类似的有趣的工作。</p>
</blockquote>
<h2 id="虚拟化CPU"><a href="#虚拟化CPU" class="headerlink" title="虚拟化CPU"></a>虚拟化CPU</h2><p>此处主要说明了操作系统对于CPU的虚拟化能力，对单核CPU的串行调度。</p>
<blockquote>
<p>这里书中有一个例子展示了虚拟化CPU，操作系统在单CPU设备上调度多个进程。</p>
</blockquote>
<h2 id="虚拟化内存"><a href="#虚拟化内存" class="headerlink" title="虚拟化内存"></a>虚拟化内存</h2><p>多进程通过虚拟内存共享物理内存</p>
<blockquote>
<p>例子展示了多进程共享相同的内存地址，就好像每个进程都有自己的私有内存。（展示这里例子要关闭进程地址随机化，参数是<code>/proc/sys/kernel/randomize_va_space</code>）</p>
</blockquote>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>简单来说就是通过多线程之间的共享变量，会对非原子操作有影响。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../include/common_threads.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// volatile 标志这个变量可能不仅有当前程序改变，也可以被某些编译器未知的因素更改，比如操作系统、硬件或者其它线程等，添加该关键字后编译器将不对该变量优化，每次都是去内存里读</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实在这里加不加volatile都可以，主要是加了volatile很容易触发问题</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> loops;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">work</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;loops;i++) &#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: thread &lt;value&gt;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    loops = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> p1,p2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Initial value: %d\n&quot;</span>,counter);</span><br><span class="line"></span><br><span class="line">    Pthread_create(&amp;p1,<span class="literal">NULL</span>,work,<span class="literal">NULL</span>);</span><br><span class="line">    Pthread_create(&amp;p2,<span class="literal">NULL</span>,work,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    Pthread_join(p1,<span class="literal">NULL</span>);</span><br><span class="line">    Pthread_join(p2,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Final value : %d\n&quot;</span>,counter);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h2><p>介绍文件系统，性能优化，驱动等。</p>
<h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><p>它取得 CPU、内存或磁盘等物理资源（resources），甚对它们进行虚拟化（virtualize）。它处理与甚发（concurrency）有关的麻烦且棘手的问题。它持久地（persistently）存储文件，从而使它们长期随全。</p>
<ul>
<li>隔离</li>
<li>可靠性</li>
<li>安全性</li>
<li>移动性</li>
</ul>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用和过程调用之间的关键区别在于，系统调用将控制转移（跳转）到 OS 中，同时提高硬件特权级别（hardware privilege level）。用户应用程序以所谓的用户模式（user mode）运行，这意味着硬件限制了应用程序的功能。例如，以用户模式运行的应用程序通常不能发起对磁盘的I&#x2F;O 请求，不能访问任何物理内存页或在网络上发送数据包。在发起系统调用时通常通过一个称为陷阱（trap）的特殊硬件指令，硬件将控制转移到预先指定的陷阱处理程序（trap handler）（即预先设置的操作系统），甚同时将特权级别提升到内核模式（kernel mode）。在内核模式下，操作系统可以完全访问系统的硬件，因此可以执行诸如发起I&#x2F;O 请求或为程序提供更多内存等功能。当操作系统完成请求的服务时，它通过特殊的陷阱返回<br>（return-from-trap）指令将控制权交还给用户，该指令返回到用户模式，同时将控制权交还给应用程序，回到应用离开的地方。</p>
<hr>
<blockquote>
<p>后续简单介绍了操作系统的发展历史，这里就不再赘述了</p>
</blockquote>
<h1 id="第三章-关于虚拟化的对话"><a href="#第三章-关于虚拟化的对话" class="headerlink" title="第三章 关于虚拟化的对话"></a>第三章 关于虚拟化的对话</h1><blockquote>
<p>跳过</p>
</blockquote>
<h1 id="第4章-抽象：进程"><a href="#第4章-抽象：进程" class="headerlink" title="第4章 抽象：进程"></a>第4章 抽象：进程</h1><p>通过时分技术实现多进程共享CPU。</p>
<blockquote>
<p>操作系统会通过一系列的策略对进程占用时间片进行管理，同时对于硬件资源操作系统也会做相应的统一管理。</p>
</blockquote>
<h2 id="抽象：进程"><a href="#抽象：进程" class="headerlink" title="抽象：进程"></a>抽象：进程</h2><p>进程的机器状态：</p>
<ul>
<li>内存：指令和读取写入的数据都在内存里。</li>
<li>寄存器：用于读取存储指令，如程序计数器，栈指针和相关帧指针</li>
</ul>
<h2 id="进程API"><a href="#进程API" class="headerlink" title="进程API"></a>进程API</h2><p>操作系统必须以某种形式提供这些API：</p>
<ul>
<li>创建(create)</li>
<li>销毁(destory)</li>
<li>等待(wait)</li>
<li>其他控制(miscellaneous control)：除了杀死或等待，可能还要一些其他控制，例如暂停进程</li>
<li>状态(state)：提供当前进程的状态信息</li>
</ul>
<h2 id="进程创建：更多细节"><a href="#进程创建：更多细节" class="headerlink" title="进程创建：更多细节"></a>进程创建：更多细节</h2><p>操作系统是如何运行一个程序：</p>
<ol>
<li>将代码和静态数据（例如初始化变量）从硬盘加载到内存中，加载到进程的地址空间中。<br><img src="/2022/04/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/load_process.jpg"><blockquote>
<p>在早期的操作系统采用的加载方式是将进程一次性的加载到内存中，但是现代操作系统采用的加载方式是惰性加载，其实这里涉及到内存交换，内存虚拟化相应的知识。</p>
</blockquote>
</li>
<li>为程序运行时栈分配一些内存，用来存放局部变量，函数参数和返回值，实际上根据程序操作系统也会为程序的堆分配一些内存。</li>
<li>其他初始化工作如：I&#x2F;O初始化(Unix默认打开3个文件描述符)。<blockquote>
<p>这里涉及到I&#x2F;O和文件描述符的知识</p>
</blockquote>
</li>
<li>启动程序，OS将CPU的控制权转移到新创建的进程中</li>
</ol>
<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><ul>
<li>运行(runing)：进程正在处理器上运行，正在执行指令</li>
<li>就绪(ready)：就绪状态下，进程已准备好运行，但是由于某种原因操作系统不运行</li>
<li>阻塞(blocked)：一个进程执行了某种操作，知道发生其他事件才会准备运行，如：I&#x2F;O操作，他会被阻塞，其他进程可以使用CPU</li>
</ul>
<p><img src="/2022/04/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/process_state_machine.jpg"></p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>操作系统通过进程李彪来跟踪当前运行的进程，操作系统还必须以某种方式跟踪被阻塞的进程。</p>
<p>通过xv6进程数据结构：</p>
<blockquote>
<p>实际上xv6最新版本的代码和书上的代码有些出入，和书中一致的提交号为<code>943fd37</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Saved registers for kernel context switches.</span></span><br><span class="line"><span class="comment">// Don&#x27;t need to save all the %fs etc. segment registers,</span></span><br><span class="line"><span class="comment">// because they are constant across kernel contexts.</span></span><br><span class="line"><span class="comment">// Save all the regular registers so we don&#x27;t need to care</span></span><br><span class="line"><span class="comment">// which are caller save, but not the return register %eax.</span></span><br><span class="line"><span class="comment">// (Not saving %eax just simplifies the switching code.)</span></span><br><span class="line"><span class="comment">// The layout of context must match code in swtch.S.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> eip;</span><br><span class="line">  <span class="keyword">int</span> esp;</span><br><span class="line">  <span class="keyword">int</span> ebx;</span><br><span class="line">  <span class="keyword">int</span> ecx;</span><br><span class="line">  <span class="keyword">int</span> edx;</span><br><span class="line">  <span class="keyword">int</span> esi;</span><br><span class="line">  <span class="keyword">int</span> edi;</span><br><span class="line">  <span class="keyword">int</span> ebp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> &#123;</span> UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> *mem;                <span class="comment">// Start of process memory (kernel address)</span></span><br><span class="line">  uint sz;                  <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="keyword">char</span> *kstack;             <span class="comment">// Bottom of kernel stack for this process</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> <span class="title">state</span>;</span>    <span class="comment">// Process state</span></span><br><span class="line">  <span class="keyword">int</span> pid;                  <span class="comment">// Process ID</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>      <span class="comment">// Parent process</span></span><br><span class="line">  <span class="keyword">void</span> *chan;               <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="keyword">int</span> killed;               <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>        <span class="comment">// Current directory</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>   <span class="comment">// Switch here to run process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span>     <span class="comment">// Trap frame for current interrupt</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">16</span>];            <span class="comment">// Process name (debugging)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process memory is laid out contiguously, low addresses first:</span></span><br><span class="line"><span class="comment">//   text</span></span><br><span class="line"><span class="comment">//   original data and bss</span></span><br><span class="line"><span class="comment">//   fixed-size stack</span></span><br><span class="line"><span class="comment">//   expandable heap</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-CPU state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line">  uchar apicid;               <span class="comment">// Local APIC ID</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span>;</span>       <span class="comment">// Process currently running.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// Switch here to enter scheduler</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">taskstate</span> <span class="title">ts</span>;</span>        <span class="comment">// Used by x86 to find stack for interrupt</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">segdesc</span> <span class="title">gdt</span>[<span class="title">NSEGS</span>];</span>  <span class="comment">// x86 global descriptor table</span></span><br><span class="line">  <span class="keyword">volatile</span> uint booted;        <span class="comment">// Has the CPU started?</span></span><br><span class="line">  <span class="keyword">int</span> ncli;                   <span class="comment">// Depth of pushcli nesting.</span></span><br><span class="line">  <span class="keyword">int</span> intena;                 <span class="comment">// Were interrupts enabled before pushcli? </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="process-run-py"><a href="#process-run-py" class="headerlink" title="process-run.py"></a><code>process-run.py</code></h2><p>使用模拟器：<code>process-run.py</code><br>主要参数介绍：</p>
<ul>
<li>-l：x:y , x为需要执行的指令数，y为是cpu指令的几率，如果是100则是cpu指令，如果是0的话就是I&#x2F;O指令</li>
<li>-L：I&#x2F;O指令耗时</li>
<li>-S：进程切换特性，两个参数：SWITCH_ON_IO，SWITCH_ON_END</li>
<li>-I：I&#x2F;O处理特性，两个参数：IO_RUN_LATER，IO_RUN_IMMEDIATE</li>
<li>-c：计算答案</li>
<li>-p：打印数据统计</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>通过<code>scheduler.load()</code>载入指令，通过<code>scheduler.run()</code>对指令进行编排</p>
<blockquote>
<p>通过对指令排列进行模拟CPU行为</p>
</blockquote>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><h5 id="SWITH-ON-END"><a href="#SWITH-ON-END" class="headerlink" title="SWITH_ON_END"></a>SWITH_ON_END</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@giddypoet cpu-intro]# ./process-run.py -l 1:0,4:100 -c -p -S SWITCH_ON_END</span><br><span class="line">Time        PID: 0        PID: 1           CPU           IOs</span><br><span class="line">  1         RUN:io         READY             1          </span><br><span class="line">  2        WAITING         READY                           1</span><br><span class="line">  3        WAITING         READY                           1</span><br><span class="line">  4        WAITING         READY                           1</span><br><span class="line">  5        WAITING         READY                           1</span><br><span class="line">  6        WAITING         READY                           1</span><br><span class="line">  7*   RUN:io_done         READY             1          </span><br><span class="line">  8           DONE       RUN:cpu             1          </span><br><span class="line">  9           DONE       RUN:cpu             1          </span><br><span class="line"> 10           DONE       RUN:cpu             1          </span><br><span class="line"> 11           DONE       RUN:cpu             1          </span><br><span class="line"></span><br><span class="line">Stats: Total Time 11</span><br><span class="line">Stats: CPU Busy 6 (54.55%)</span><br><span class="line">Stats: IO Busy  5 (45.45%)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行I&#x2F;O时不切换</p>
</blockquote>
<h5 id="SWITCH-ON-IO"><a href="#SWITCH-ON-IO" class="headerlink" title="SWITCH_ON_IO"></a>SWITCH_ON_IO</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@giddypoet cpu-intro]# ./process-run.py -l 1:0,4:100 -c -p -S SWITCH_ON_IO</span><br><span class="line">Time        PID: 0        PID: 1           CPU           IOs</span><br><span class="line">  1         RUN:io         READY             1          </span><br><span class="line">  2        WAITING       RUN:cpu             1             1</span><br><span class="line">  3        WAITING       RUN:cpu             1             1</span><br><span class="line">  4        WAITING       RUN:cpu             1             1</span><br><span class="line">  5        WAITING       RUN:cpu             1             1</span><br><span class="line">  6        WAITING          DONE                           1</span><br><span class="line">  7*   RUN:io_done          DONE             1          </span><br><span class="line"></span><br><span class="line">Stats: Total Time 7</span><br><span class="line">Stats: CPU Busy 6 (85.71%)</span><br><span class="line">Stats: IO Busy  5 (71.43%)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行I&#x2F;O时切换</p>
</blockquote>
<h4 id="I-x2F-O切换"><a href="#I-x2F-O切换" class="headerlink" title="I&#x2F;O切换"></a>I&#x2F;O切换</h4><h5 id="IO-RUN-LATER"><a href="#IO-RUN-LATER" class="headerlink" title="IO_RUN_LATER"></a>IO_RUN_LATER</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@giddypoet cpu-intro]# ./process-run.py -l 2:0,6:100 -c -p -I IO_RUN_LATER</span><br><span class="line">Time        PID: 0        PID: 1           CPU           IOs</span><br><span class="line">  1         RUN:io         READY             1          </span><br><span class="line">  2        WAITING       RUN:cpu             1             1</span><br><span class="line">  3        WAITING       RUN:cpu             1             1</span><br><span class="line">  4        WAITING       RUN:cpu             1             1</span><br><span class="line">  5        WAITING       RUN:cpu             1             1</span><br><span class="line">  6        WAITING       RUN:cpu             1             1</span><br><span class="line">  7*         READY       RUN:cpu             1          </span><br><span class="line">  8    RUN:io_done          DONE             1          </span><br><span class="line">  9         RUN:io          DONE             1          </span><br><span class="line"> 10        WAITING          DONE                           1</span><br><span class="line"> 11        WAITING          DONE                           1</span><br><span class="line"> 12        WAITING          DONE                           1</span><br><span class="line"> 13        WAITING          DONE                           1</span><br><span class="line"> 14        WAITING          DONE                           1</span><br><span class="line"> 15*   RUN:io_done          DONE             1          </span><br><span class="line"></span><br><span class="line">Stats: Total Time 15</span><br><span class="line">Stats: CPU Busy 10 (66.67%)</span><br><span class="line">Stats: IO Busy  10 (66.67%)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>I&#x2F;O操作等待上一个cpu指令完成后才开始</p>
</blockquote>
<h5 id="IO-RUN-IMMEDIATE"><a href="#IO-RUN-IMMEDIATE" class="headerlink" title="IO_RUN_IMMEDIATE"></a>IO_RUN_IMMEDIATE</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@giddypoet cpu-intro]# ./process-run.py -l 2:0,6:100 -c -p -I IO_RUN_IMMEDIATE</span><br><span class="line">Time        PID: 0        PID: 1           CPU           IOs</span><br><span class="line">  1         RUN:io         READY             1          </span><br><span class="line">  2        WAITING       RUN:cpu             1             1</span><br><span class="line">  3        WAITING       RUN:cpu             1             1</span><br><span class="line">  4        WAITING       RUN:cpu             1             1</span><br><span class="line">  5        WAITING       RUN:cpu             1             1</span><br><span class="line">  6        WAITING       RUN:cpu             1             1</span><br><span class="line">  7*   RUN:io_done         READY             1          </span><br><span class="line">  8         RUN:io         READY             1          </span><br><span class="line">  9        WAITING       RUN:cpu             1             1</span><br><span class="line"> 10        WAITING          DONE                           1</span><br><span class="line"> 11        WAITING          DONE                           1</span><br><span class="line"> 12        WAITING          DONE                           1</span><br><span class="line"> 13        WAITING          DONE                           1</span><br><span class="line"> 14*   RUN:io_done          DONE             1          </span><br></pre></td></tr></table></figure>

<blockquote>
<p>I&#x2F;O指令立即开始，中断正在运行的cpu指令</p>
</blockquote>
<blockquote>
<p>两者的区别在于I&#x2F;O操作执行完是CPU先接受下一个I&#x2F;O请求，还是运行进程指令。由于采用默认模式SWITCH_ON_IO，CPU执行指令与I&#x2F;O操作同时进行，因而 IO_RUN_IMMEDIATE快一个单位时间。</p>
</blockquote>
<h2 id="第五章-插叙：进程API"><a href="#第五章-插叙：进程API" class="headerlink" title="第五章 插叙：进程API"></a>第五章 插叙：进程API</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><h3 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello from child %d\n&quot;</span>,getpid());</span><br><span class="line">        <span class="comment">//exit(0);</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        pid = wait(&amp;status);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent status %d (wait status %d),parent pid %d\n&quot;</span>, pid , status, getpid());</span><br><span class="line">        <span class="keyword">if</span>(WIFEXITED(status)) </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;exit code %d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">        <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;signal exit %d\n&quot;</span>, WSTOPSIG(status));</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;                                        </span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际上发现如果子进程没有指定退出时的返回值时，我当前环境返回的exit code不定</p>
</blockquote>
<blockquote>
<p>wait返回的是进程id，子进程调用wait后会立马返回，由于子进程没有子进程因此返回值为-1</p>
</blockquote>
<h3 id="exec系统调用"><a href="#exec系统调用" class="headerlink" title="exec系统调用"></a>exec系统调用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg,</span></span></span><br><span class="line"><span class="params"><span class="function">           ..., <span class="keyword">char</span> * <span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvpe</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[],</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>查找方式：带p的，表示可以通过环境变量查找响应的命令，可以只给出文件名，而不用给出完整的路径，不带p的则需要添加完整的路径</li>
<li>参数传递方式：带l表示逐个列举的形式，带v表示可以将所有参数构造成一个指针数组传递，首地址当做参数传递，数组中的最后一个指针要求是NULL</li>
<li>环境变量：exec函数族默认使用了系统默认的环境变量，也可以传入指定的环境变量，以e结尾的两个函数就可以在envp[]中指定当前进程使用的环境变量替换掉该进程所继承的所有环境变量</li>
</ul>
<p><img src="/2022/04/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/exec_faimly.jpg"></p>
<blockquote>
<p>实际上操作系统真正的系统调用只有execve，其他5个都是库函数，它们最终都会调用evecve这个系统调用<br>同时由于exec函数族替换了当前进程的堆栈信息，并替换成不同的程序，因此在exec函数族之后执行的代码通常不会执行，除非exec函数族执行失败。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果此时没有换行符，当前操作系统又是行缓冲，则有可能不会输出任何信息</span></span><br><span class="line">        <span class="comment">// printf(&quot;fork child \n&quot;);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork child \n&quot;</span>);</span><br><span class="line">        <span class="comment">// fflush(stdout);</span></span><br><span class="line">        close(STDOUT_FILENO);</span><br><span class="line">        open(<span class="string">&quot;./output.txt&quot;</span>,O_CREAT|O_WRONLY|O_TRUNC, S_IRWXU);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> * myargs[<span class="number">3</span>];</span><br><span class="line">        myargs[<span class="number">0</span>] = <span class="string">&quot;wc&quot;</span>;</span><br><span class="line">        myargs[<span class="number">1</span>] = <span class="string">&quot;wait.c&quot;</span>;</span><br><span class="line">        myargs[<span class="number">2</span>] = <span class="literal">NULL</span>;</span><br><span class="line">        execvp(myargs[<span class="number">0</span>],myargs);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">char</span> *myargs[<span class="number">3</span>];</span><br><span class="line">    myargs[<span class="number">0</span>] = <span class="string">&quot;/bin/ls&quot;</span>;</span><br><span class="line">    myargs[<span class="number">1</span>] = <span class="string">&quot;./&quot;</span>;</span><br><span class="line">    myargs[<span class="number">2</span>] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork error.\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// no.1</span></span><br><span class="line">        <span class="comment">// execl(&quot;/bin/ls&quot;,&quot;ls&quot;, &quot;./&quot;);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// no.2</span></span><br><span class="line">        <span class="comment">// execv(myargs[0],myargs);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// no.3</span></span><br><span class="line">        <span class="comment">// execlp(&quot;ls&quot;,&quot;ls&quot;,&quot;./&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// no.4</span></span><br><span class="line">        <span class="comment">// execvp(myargs[0],myargs);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// no.5</span></span><br><span class="line">        <span class="comment">// execle(&quot;/bin/ls&quot;,&quot;ls&quot;,&quot;./&quot;,NULL);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// no.6</span></span><br><span class="line">        execve(myargs[<span class="number">0</span>],myargs,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="vfork"><a href="#vfork" class="headerlink" title="vfork"></a>vfork</h3><p>vfork和fork之间的区别：</p>
<ul>
<li>fork本身父子进程的执行顺序不确定，但是vfork保证子进程先运行，再它调用exec或exit后父进程才能被调度。</li>
<li>同时fork创建的子进程是父进程的一个复制品，而vfork创建的子进程共享父进程的地址空间</li>
</ul>
<h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><blockquote>
<p>注意习题8中dup和pipe相关的函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dup是将oldfd复制给最小的未被使用的文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfd)</span></span>;</span><br><span class="line"><span class="comment">// dup2是将oldfd复制给newfd文件描述符，如果newfd存在，则将newfd先关闭，如果不存在直接复制</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd)</span></span>;</span><br><span class="line"><span class="comment">// pipe pipefd[0] read pipefd[1] write</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> pipefd[<span class="number">2</span>])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将管道连在一起的操作</span></span><br><span class="line">pipe(pipefd);</span><br><span class="line"><span class="comment">// clild fork 1</span></span><br><span class="line">dup2(pipefd[<span class="number">1</span>], STDOUT_FILENO);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line"><span class="comment">// child fork 2</span></span><br><span class="line">dup2(pipefd[<span class="number">0</span>], STDIN_FILENO);</span><br><span class="line">gets(buf);</span><br><span class="line"><span class="built_in">puts</span>(buf);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="第6章-机制：受限直接执行"><a href="#第6章-机制：受限直接执行" class="headerlink" title="第6章 机制：受限直接执行"></a>第6章 机制：受限直接执行</h2><p>虚拟化CPU支持多任务共享物理CPU，通过时分共享CPU，实现CPU虚拟化，因此引入了如下问题：</p>
<ul>
<li>性能，如何不增加系统开销实现虚拟化</li>
<li>控制权，有效地运行进程，同时保留对CPU的控制</li>
</ul>
<blockquote>
<p>简单来说就是如何高效、可控地虚拟化CPU</p>
</blockquote>
<p>为了限制进程的操作，演化出了用户模式和内核模式：</p>
<ul>
<li>用户模式，代码受限，不能直接访问I&#x2F;O</li>
<li>内核模式，代码可以执行它喜欢做的事，包括特权操作</li>
</ul>
<p>简单来说就是通过trap和return from trap实现的系统返回。</p>
<p>用户态内核切换：</p>
<ul>
<li>系统调用</li>
<li>Page fault， 运算时除以0的错误</li>
<li>一个设备触发了中断使得当前程序运行需要响应内核设备驱动</li>
</ul>
<blockquote>
<p>上述切换中，只有1和2涉及到trap的范畴，而3是一个中断的典型例子</p>
</blockquote>
<h3 id="trap"><a href="#trap" class="headerlink" title="trap"></a>trap</h3><p>在遇到trap时，操作系统通常会执行如下操作：</p>
<ol>
<li>先保护现场，保存当前32个用户寄存器，保存pc，用于从内核态返回后，继续执行用户态程序（这些寄存器设计多种功能，有为保存用户进程状态，有为trap提供工作基础等）</li>
<li>进入内核态，从user mode修改为supervisor mode，将SATP指向内核对应的页表</li>
</ol>
<blockquote>
<p>trap table以及userrecv等相关信息需要后续学习</p>
</blockquote>
<h3 id="在进程间切换"><a href="#在进程间切换" class="headerlink" title="在进程间切换"></a>在进程间切换</h3><h4 id="协作方式：等待系统调用"><a href="#协作方式：等待系统调用" class="headerlink" title="协作方式：等待系统调用"></a>协作方式：等待系统调用</h4><p>在这种模式下操作系统认为系统进程会合理的运行，运行时间过长的进程被假定会定期放弃CPU，以便操作系统能够决定运行其他任务。</p>
<ul>
<li>通过系统调用或者触发非法操作，将CPU的控制权交给操作系统。</li>
</ul>
<blockquote>
<p>实际上这个方式已经被遗弃，如果某个进程进入无线循环，并且从来不进行调用，会导致操作系统不能获取到CPU的控制权</p>
</blockquote>
<h4 id="非协作方式"><a href="#非协作方式" class="headerlink" title="非协作方式"></a>非协作方式</h4><p>没有硬件的额外帮助下，在上述方式下无法打断一个从来不进行系统调用的无限循环进程，因此需要借助外部设备来实现操作系统重新获取CPU控制权。</p>
<ul>
<li>利用时钟中断重新获取控制权，操作系统通过预先配置的时钟中断程序，重新获取CPU的控制权，来进行进程间的切换。</li>
</ul>
<h4 id="恢复和保存上下文"><a href="#恢复和保存上下文" class="headerlink" title="恢复和保存上下文"></a>恢复和保存上下文</h4><p>操作系统进程调度机制是有调度程序(scheduler)做出的，它是操作系统的一部分。</p>
<p>如果决定进行切换，OS就会执行一些底层代码，即所谓的上下文切换，上下文切换做的操作：</p>
<ul>
<li>操作系统为当前正在执行的进程保存一些寄存器的值，到它的内核栈中</li>
<li>同时将要执行的进程恢复一些寄存器的值</li>
</ul>
<blockquote>
<p>实际上操作系统会执行一些底层的汇编代码来保存和恢复通用寄存器、程序计数器，完成这一系列的操作后从陷阱返回指令时，就会将执行的进程变成当前进行的进程。</p>
</blockquote>
<h3 id="作业测量"><a href="#作业测量" class="headerlink" title="作业测量"></a>作业测量</h3><blockquote>
<p>通过sched_setaffinity实现将进程绑定到cpu核上，测试进程间切换，通过管道时间进程间的通信，用通信时间差值算出上下文切换花费的时间</p>
</blockquote>
<h2 id="第7章-进程调度：介绍"><a href="#第7章-进程调度：介绍" class="headerlink" title="第7章 进程调度：介绍"></a>第7章 进程调度：介绍</h2><h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><p>优势：<br>简单易于实现，在进程工作大致相同的时间是，可以完成。</p>
<p>劣势：<br>当某一个进程执行时间过长，导致系统的平均周转时间过长。</p>
<h3 id="SJF（最短任务优先）"><a href="#SJF（最短任务优先）" class="headerlink" title="SJF（最短任务优先）"></a>SJF（最短任务优先）</h3><p>在非抢占式模式下，实际上无法解决护航问题，同时最短任务只在理论上可信，实际工程场景中无法区分最短任务。</p>
<h3 id="STCF（最短完成时间优先）"><a href="#STCF（最短完成时间优先）" class="headerlink" title="STCF（最短完成时间优先）"></a>STCF（最短完成时间优先）</h3><p>在SJF上叠加抢占，称为最短完成时间优先。每当新的工作进入系统时，它就会确定剩余工作和新工作中，谁的剩余时间更少，然后调度该工作。</p>
<h3 id="新度量指标：响应时间"><a href="#新度量指标：响应时间" class="headerlink" title="新度量指标：响应时间"></a>新度量指标：响应时间</h3><p>首次运行时间 - 到达时间 &#x3D; 响应时间</p>
<h3 id="轮转"><a href="#轮转" class="headerlink" title="轮转"></a>轮转</h3><p>为程序分配不同的时间片，在不同的时间片运行不同的工作。</p>
<p>系统设计者需要权衡时间片长度，通过将时间片分给不同的工作，使其足够长，以便摊销上下文切换成本，并且不会使系统不及时响应。</p>
<blockquote>
<p>实际上要减少上下文切换在进程执行中所占用的时间，需要对时间片的长度进行考量<br>同时上下文件切换将带来大量的性能成本，CPU高速缓存、TLB、分支预测和其他片上硬件建立大量的状态，切换后导致明显的性能成本。</p>
</blockquote>
<h3 id="结合I-x2F-O"><a href="#结合I-x2F-O" class="headerlink" title="结合I&#x2F;O"></a>结合I&#x2F;O</h3><blockquote>
<p>简单来说在执行I&#x2F;O的时候CPU由其他工作抢占，等I&#x2F;O完成后，触发中断，CPU回到之前的工作。</p>
</blockquote>
<h2 id="第8章-调度：多级反馈队列"><a href="#第8章-调度：多级反馈队列" class="headerlink" title="第8章 调度：多级反馈队列"></a>第8章 调度：多级反馈队列</h2><h3 id="MLFQ：基本规则"><a href="#MLFQ：基本规则" class="headerlink" title="MLFQ：基本规则"></a>MLFQ：基本规则</h3><ul>
<li>通过多个队列区分不同的优先级，任何时刻一个工作只能存在一个队列中，MLFQ总是优先执行较高优先级的工作。</li>
<li>每个队列中可能有多个工作，同样的优先级下，对这些队列采用轮转调度</li>
</ul>
<blockquote>
<p>MLFQ核心问题在于如何设置优先级，MLFQ会根据进程行为学习其行为，预测动态调整其优先级</p>
</blockquote>
<h3 id="如何改变优先级"><a href="#如何改变优先级" class="headerlink" title="如何改变优先级"></a>如何改变优先级</h3>
	
	</div>
  <a type="button" href="/2022/04/18/操作系统导论/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/04/12/计算机是怎样跑起来的/" >计算机是怎样跑起来的</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-04-12  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<blockquote>
<p>&lt;&lt;计算机是怎么跑起来的&gt;&gt; 读书笔记</p>
</blockquote>
<h1 id="计算机三大原则"><a href="#计算机三大原则" class="headerlink" title="计算机三大原则"></a>计算机三大原则</h1><h2 id="计算机的三个根本性基础"><a href="#计算机的三个根本性基础" class="headerlink" title="计算机的三个根本性基础"></a>计算机的三个根本性基础</h2><ol>
<li>计算机是执行输入、运算、输出的机器</li>
<li>程序是指令和数据的集合</li>
<li>计算机的处理方式与人们的思维习惯不同</li>
</ol>
<h2 id="输入、运算、输出是硬件的基础"><a href="#输入、运算、输出是硬件的基础" class="headerlink" title="输入、运算、输出是硬件的基础"></a>输入、运算、输出是硬件的基础</h2><p>计算机是执行输入、运算、输出三种操作的机器。IC电路引脚也是围绕这个点进行设计的。</p>
<h2 id="软件是指令和数据的集合"><a href="#软件是指令和数据的集合" class="headerlink" title="软件是指令和数据的集合"></a>软件是指令和数据的集合</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump xxx</span><br></pre></td></tr></table></figure>

<h2 id="对计算机来说什么都是数字"><a href="#对计算机来说什么都是数字" class="headerlink" title="对计算机来说什么都是数字"></a>对计算机来说什么都是数字</h2><blockquote>
<p>这一章围绕作者提出的计算机的三个根本性基础，举例阐述佐证了作者的观点。</p>
</blockquote>
<h1 id="试着制造一台计算机吧"><a href="#试着制造一台计算机吧" class="headerlink" title="试着制造一台计算机吧"></a>试着制造一台计算机吧</h1><h2 id="制作微型计算机所必需的元件"><a href="#制作微型计算机所必需的元件" class="headerlink" title="制作微型计算机所必需的元件"></a>制作微型计算机所必需的元件</h2><p>基础元件：</p>
<ol>
<li>cpu：解释、执行程序（文中采用的是Z80 CPU）</li>
<li>内存：存储程序和数据（文中采用的是TC5517）</li>
<li>I&#x2F;O：连接外部设备（文中采用的是Z80 PIO）</li>
</ol>
<p>为了驱动CPU运转，时钟信号必不可少，通过高低电平切换，驱动CPU操作。简单来说时钟信号用于同步操作。</p>
<blockquote>
<p>下述其实是D触发器，当CLK为高电平的时候，当clk是1的时候，D的值就会被写进去，然后clk&#x3D;0的时候，Q就会一直是之前那个D，clk是0的时候，D的值再变，Q也不会变。为什么需要clk呢，因为你的设计里面，这个寄存器在等上一个寄存器的数据，你不知道上一个寄存器的数据存好了没，是新的还是旧的，你要写进去的数据写好了没。如果每个寄存器都用不同的clk，这样设计很容易不同步async，就是我想同时写几个register，但是这个register已经写完了，那个我不知道他存好了没，全局的clk能帮助解决很多这类问题。这个clk很大程度上左右了设计里面很多东西的读写速度。</p>
</blockquote>
<blockquote>
<p>当然，实际上的设计一般clk还会AND 一个叫enable的输入，那么当enable是0的时候，clk那边就一直是0，你要写进去这个flipflop，就需要enable&#x3D;1，clk&#x3D;1，这时候D就被存进去了。</p>
</blockquote>
<p><img src="/2022/04/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/register.png"></p>
<p>输入程序的装置也是必不可少的，通过拨动指拨开关来输入程序，8个开关作为输入元件，输出元件是8个LED。</p>
<p>同时还有DMA，将输入输出直接写入内存当中。</p>
<blockquote>
<p>此章节主要介绍了计算机的组成，设计到一些嵌入式单片机的知识，未做详细的描述，将其略过。</p>
</blockquote>
<h1 id="体验一次手工汇编"><a href="#体验一次手工汇编" class="headerlink" title="体验一次手工汇编"></a>体验一次手工汇编</h1><p>实际上通过上述计算机输入的二进制序列，实现汇编指令，驱动CPU实现指令。</p>
<blockquote>
<p>这里不再赘述</p>
</blockquote>
<h1 id="程序像河水一样流动着"><a href="#程序像河水一样流动着" class="headerlink" title="程序像河水一样流动着"></a>程序像河水一样流动着</h1><h2 id="程序的流程分为三种"><a href="#程序的流程分为三种" class="headerlink" title="程序的流程分为三种"></a>程序的流程分为三种</h2><p>计算机的硬件系统由CPU、I&#x2F;O和内存三部分构成。内存中存储这程序，也就是指令和数据。CPU配合着时钟发生器的时钟信号，从内存中读出指令，然后再依次对其进行解释和执行。</p>
<p>CPU中有各种各样的各司其职的寄存器。其中有一个被称为PC（Program Counter，程序计数器）的寄存器，负责存储内存地址，该地址指向下一条即将执行的指令，每解释执行完一条指令，PC寄存器的值就会自动被更新为下一条指令的地址。</p>
<p><img src="/2022/04/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/pc_register.jpg"></p>
<p>实际上程序的流程总共有三种，由PC控制器控制：</p>
<ol>
<li>顺序执行</li>
<li>条件分支</li>
<li>循环</li>
</ol>
<h2 id="特殊的程序流程–中断处理"><a href="#特殊的程序流程–中断处理" class="headerlink" title="特殊的程序流程–中断处理"></a>特殊的程序流程–中断处理</h2><p>处理中断</p>
<hr>
<blockquote>
<p>该书后续的介绍都较为浅显，偏入门的知识介绍，暂时不在阅读</p>
</blockquote>

	
	</div>
  <a type="button" href="/2022/04/12/计算机是怎样跑起来的/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/04/10/dpdk深入浅出/" >dpdk深入浅出</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-04-10  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h1 id="第一章-认识DPDK"><a href="#第一章-认识DPDK" class="headerlink" title="第一章 认识DPDK"></a>第一章 认识DPDK</h1><h2 id="主流包处理硬件平台"><a href="#主流包处理硬件平台" class="headerlink" title="主流包处理硬件平台"></a>主流包处理硬件平台</h2><p>简单介绍了当前从互联网面临的挑战：<code>从计算密集型设备转换为IO密集型设备</code>，同时介绍了当前主流包处理的硬件平台，并对其在不同领域的优缺点做了阐述：</p>
<ol>
<li>硬件加速器：适用于功能固化，功能具有高性能低成本的特点</li>
<li>网络处理器：提供了包处理逻辑软件可编程的能力，在获得灵活性的同事兼顾了高性能的硬件包处理</li>
<li>多核处理器：更为复杂多变的高层包处理上拥有优势</li>
</ol>
<h3 id="硬件加速器"><a href="#硬件加速器" class="headerlink" title="硬件加速器"></a>硬件加速器</h3><p>ASIC和FPGA。</p>
<blockquote>
<p>涉及集成电路和嵌入式设备，这里不再赘述。</p>
</blockquote>
<h3 id="网络处理器"><a href="#网络处理器" class="headerlink" title="网络处理器"></a>网络处理器</h3><p>网络处理器(Network  Processer  Unit，NPU)是专门为处理数据包而设计的可编程通用处理器，采用多内核并行处理结构，其常被应用于通信领域的各种任务，比如包处理、协议分析、路由查找、声音&#x2F;数据<br>的汇聚、防火墙、QoS等。</p>
<h3 id="多核处理器"><a href="#多核处理器" class="headerlink" title="多核处理器"></a>多核处理器</h3><p>由当前CPU性能的扩展方式引入了SOC，同时简单介绍了当前主流厂商的多核处理器的SOC平台。</p>
<h2 id="初识DPDK"><a href="#初识DPDK" class="headerlink" title="初识DPDK"></a>初识DPDK</h2><h3 id="IA-intel-architecture-不适合进行数据包处理吗"><a href="#IA-intel-architecture-不适合进行数据包处理吗" class="headerlink" title="IA(intel architecture)不适合进行数据包处理吗"></a>IA(intel architecture)不适合进行数据包处理吗</h3><p>传统linux包处理流程:</p>
<ol>
<li>数据包到达网卡</li>
<li>网卡设备依据配置进行DMA操作，简单来说就是将网卡中的数据直接拷贝到内存中，避免cpu浪费大量的时间片用于数据拷贝。（其实总线上有一个总的DMA控制器用于做DMA操作，不仅网卡，同时硬盘等其他IO设备都要使用DMA控制器）</li>
<li>网卡发送中断，通知CPU。（此处还涉及多队列网卡，网卡不同的队列中断号不一样）</li>
<li>驱动软件填充读写缓冲区数据结构。</li>
<li>数据报文到达内核协议栈，进行高层处理。</li>
<li>如果最终应用在用户态，数据将从内核拷贝至用户态。（涉及零拷贝知识，mmap，sendfile等）</li>
<li>如果最终应用在内核态，在内核继续进行。</li>
</ol>
<p>影响收包性能的主要因素：</p>
<ol>
<li>cpu中断，频繁的上下文切换，导致性能低下</li>
<li>数据拷贝，从网卡拷贝到内核，从内核拷贝到用户态</li>
<li>操作系统调度线程切换，导致cache替换，线程在不同核之间频繁切换，核减线程导致cache miss和cache write back造成大量的性能损失。</li>
<li>内存页表查询，大量的IO操作会剧烈的增加内存的查找，导致性能下降。</li>
</ol>
<blockquote>
<p>上述流程会引发一个问题，即便通过DMA的形式，在IO密集型的设备上，依然会因为触发大量的中断引起大量的开销，导致系统无法承受，因此引入了NAPI机制，其策略是设定中断阈值，当网卡上的中断未超过阈值，则采用中断模式，如果中断超过阈值，则系统被中断唤醒后，尽量使用轮询的方式一次性处理多个数据包，直到网络再次空闲重新传入中断等待。</p>
</blockquote>
<blockquote>
<p>其实，在上述过程中，发现除了网卡频繁触发中断，影响包处理性能，同时在内核态和用户态之间频繁发生数据拷贝也会大大的影响包处理性能。</p>
</blockquote>
<blockquote>
<p>netmap内存映射网卡的<code>packet buffer</code>到用户态，实现了自己的收发报文的<code>circular ring</code>来对应网卡的<code>ring</code>。越过内核态。</p>
</blockquote>
<blockquote>
<p>cpu亲和性，通过CPU亲和性，将线程绑定到cpu单个核上执行，cache miss和cache write back问题。</p>
</blockquote>
<p>DPDK通过以下技术解决了上述问题：</p>
<ol>
<li>轮询替换中断，避免中断上下文切换的开销</li>
<li>用户态驱动，在这种工作方式中，规避了不必要的内存拷贝，又避免了系统调用。</li>
<li>亲和性与独占，dpdk工作在用户态，利用线程的CPU亲和绑定的方式，特定任务值在某个核上工作。好处是可避免线程在不同核间频繁切换，核间线程切换容易导致因cache miss和cache write back造成的大量性能损失。</li>
<li>降低内存开销，通过大页内存降低TLB miss，利用内存多通道的交错访问能够有效提高内存访问的有效带宽。</li>
</ol>
<h3 id="DPDK框架简介"><a href="#DPDK框架简介" class="headerlink" title="DPDK框架简介"></a>DPDK框架简介</h3><p><img src="/2022/04/10/dpdk%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/dpdk_arch.png"></p>
<ul>
<li>核心库<code>Core Libs</code>：提供系统抽象、大页内存、缓存池、定时器及无锁环等基础组件</li>
<li>PMD库：提供全用户态的驱动，以便通过轮询和线程绑定得到极高的网络吞吐，支持各种本地和虚拟网卡</li>
<li>Classify库：支持精确匹配(Exact Match)、最长匹配(LPM)和通配符匹配(ACL)，提供常用的包处理的查表操作</li>
<li>Qos库：提供网络服务质量相关组件，如限速(Meter)和调度(Sched)</li>
</ul>
<blockquote>
<p>上述是DPDK主要的库，其实还提供了一些对于运行频率调整(Power)，与<code>Linux Kernel Stack</code>建立快速通道的(KNI Kernel Network Interface)。而<code>Packet FrameWrok</code>和<code>DISTRIB</code>是为了搭建更为复杂的多核流水线处理模型提供了基础组件。</p>
</blockquote>
<h2 id="解读数据包处理能力"><a href="#解读数据包处理能力" class="headerlink" title="解读数据包处理能力"></a>解读数据包处理能力</h2><p>实际上以太网帧数据最小是64个字节，其中包括46个字节的数据部分，2个字节的协议类型，12个字节的目的mac地址和源mac地址，以及4个字节的校验和。每个以太网帧默认帧间距为12个字节，同时每个帧还有7个字节的前导，和一个自己的帧首定界，因此一个最小以太网帧为<code>46+2+12+4+12+7+1=84</code>个字节，672个bit。</p>
<p>因此10Gbit&#x2F;s的网卡最大理论帧转发率为<code>10*1000/640=14.88Mpps</code>，14.88兆个包每秒。</p>
<h2 id="探索IA处理器上最艰巨的任务"><a href="#探索IA处理器上最艰巨的任务" class="headerlink" title="探索IA处理器上最艰巨的任务"></a>探索IA处理器上最艰巨的任务</h2><p>DPDK通过一系列软件优化方法（大页利用，cache对齐，线程绑定，NUMA感知，内存通道交叉访问，无锁化数据结构，预取，SIMD指令利用等）利用IA平台硬件特性，提供完整的底层开发支持库。使得单核三层转发可以轻松地突破小包30Mpps，随着CPU封装的核数越来越多，支持的PCIe通道数越来越多，整系统的三层转发吞吐在2路CPU的Xeon E5-2658v3上可以达到300Mpps。</p>
<h2 id="软件包处理的潜力"><a href="#软件包处理的潜力" class="headerlink" title="软件包处理的潜力"></a>软件包处理的潜力</h2><p>主要介绍了DPDK的使用场景：</p>
<ol>
<li>加速网络节点，支持虚拟化部署</li>
<li>加速计算节点</li>
<li>加速存储节点</li>
</ol>
<blockquote>
<p>后续还介绍了一堆DPDK适用的场景，一大堆就不在此赘述了</p>
</blockquote>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ol>
<li>helloworld</li>
<li>skeleton</li>
<li>l3fwd</li>
</ol>
<h3 id="helloworld"><a href="#helloworld" class="headerlink" title="helloworld"></a>helloworld</h3><blockquote>
<p>ret &#x3D; runtime enviroment<br>eal &#x3D; enviroment abstraction layer<br>DPDK区分了主线程和从线程</p>
</blockquote>
<p>对调用函数进行简单的介绍</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rte_eal_init</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该函数主要是对DPDK基础运行环境进行设置，具体内容如下：</p>
<ol>
<li>配置初始化</li>
<li>内存初始化</li>
<li>内存池初始化</li>
<li>队列初始化</li>
<li>告警初始化</li>
<li>中断初始化</li>
<li>PCI初始化</li>
<li>定时器初始化</li>
<li>检测内存本地化(NUMA)</li>
<li>插件初始化</li>
<li>主线程初始化</li>
<li>轮询设备初始化</li>
<li>建立主从线程通道(通过管道)</li>
<li>将从线程设置在等待模式(<code>_mm_pause()</code>等待主线程分发任务)</li>
<li>PCI设备的探测和初始化</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RTE_LCORE_FOREACH_SLAVE(i)					\</span></span><br><span class="line"><span class="meta">	for (i = rte_get_next_lcore(-1, 1, 0);				\</span></span><br><span class="line"><span class="meta">	     i&lt;RTE_MAX_LCORE;						\</span></span><br><span class="line"><span class="meta">	     i = rte_get_next_lcore(i, 1, 0))</span></span><br></pre></td></tr></table></figure>

<p>遍历从线程，即逻辑线程。（逻辑核就是cpu当前的核数）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rte_eal_remote_launch</span><span class="params">(<span class="keyword">lcore_function_t</span> *f, <span class="keyword">void</span> *arg, <span class="keyword">unsigned</span> slave_id)</span></span>;</span><br></pre></td></tr></table></figure>

<p>主线程通过管道向从线程分发任务，将f作为函数指针传递给从线程，arg作为执行参数，在slave_id的逻辑线程上执行该函数。</p>
<blockquote>
<p>通过<code>lcore_config[RTE_MAX_LCORE]</code>数组和逻辑线程id确定管段，通过管道启动任务。</p>
</blockquote>
<p>后续任务就是简单的执行相关函数。</p>
<h3 id="Skeleton"><a href="#Skeleton" class="headerlink" title="Skeleton"></a>Skeleton</h3><p>这个示例简单说就是一个单核的转发程序，设计初衷是实现一个最简单的报文转发程序，对报文不做任何改动。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool</span> *<span class="title">mbuf_pool</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> nb_ports;</span><br><span class="line">	<span class="keyword">uint16_t</span> portid;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialize the Environment Abstraction Layer (EAL). */</span></span><br><span class="line">	<span class="keyword">int</span> ret = rte_eal_init(argc, argv);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		rte_exit(EXIT_FAILURE, <span class="string">&quot;Error with EAL initialization\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	argc -= ret;</span><br><span class="line">	argv += ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check that there is an even number of ports to send/receive on. */</span></span><br><span class="line">	nb_ports = rte_eth_dev_count_avail();</span><br><span class="line">	<span class="keyword">if</span> (nb_ports &lt; <span class="number">2</span> || (nb_ports &amp; <span class="number">1</span>))</span><br><span class="line">		rte_exit(EXIT_FAILURE, <span class="string">&quot;Error: number of ports must be even\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Creates a new mempool in memory to hold the mbufs. */</span></span><br><span class="line">	mbuf_pool = rte_pktmbuf_pool_create(<span class="string">&quot;MBUF_POOL&quot;</span>, NUM_MBUFS * nb_ports,</span><br><span class="line">		MBUF_CACHE_SIZE, <span class="number">0</span>, RTE_MBUF_DEFAULT_BUF_SIZE, rte_socket_id());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mbuf_pool == <span class="literal">NULL</span>)</span><br><span class="line">		rte_exit(EXIT_FAILURE, <span class="string">&quot;Cannot create mbuf pool\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialize all ports. */</span></span><br><span class="line">	RTE_ETH_FOREACH_DEV(portid)</span><br><span class="line">		<span class="keyword">if</span> (port_init(portid, mbuf_pool) != <span class="number">0</span>)</span><br><span class="line">			rte_exit(EXIT_FAILURE, <span class="string">&quot;Cannot init port %&quot;</span>PRIu16 <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">					portid);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rte_lcore_count() &gt; <span class="number">1</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\nWARNING: Too many lcores enabled. Only 1 used.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Call lcore_main on the master core only. */</span></span><br><span class="line">	lcore_main();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* clean up the EAL */</span></span><br><span class="line">	rte_eal_cleanup();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意其中采用了基于分支预测的&#96;likely和unlikely相关函数，这是一个性能优化的小技巧。要求编译的时候使用-O2的选项，否则优化不起作用。简单来说会将可能执行的机器码放在前面，提高cpu执行效率。</p>
</blockquote>
<ol>
<li>调用<code>rte_eal_init</code>初始化运行环境</li>
<li>分配内存池<code>rte_pktmbuf_pool_create</code>，此处调用了<code>rte_socket_id</code>保证访问的内存是近端的</li>
<li><code>port_init</code>初始化网口配置</li>
<li><code>lcore_main</code>进行主处理流程</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct rte_mempool *</span></span><br><span class="line"><span class="function"><span class="title">rte_pktmbuf_pool_create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">unsigned</span> <span class="keyword">int</span> n,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">unsigned</span> <span class="keyword">int</span> cache_size, <span class="keyword">uint16_t</span> priv_size, <span class="keyword">uint16_t</span> data_room_size,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> socket_id)</span></span>;</span><br></pre></td></tr></table></figure>
<p>内存池，这个mbuf pool主要是给网卡接收数据包提供mbuf的，当网卡通过DMA收到数据需要把数据包通过DMA传送到一块内存，正是这个mbuf pool中的内存。</p>
<ul>
<li>name：内存池名</li>
<li>n：mp里面obj的数量，在这里表示mbuf的数量，如果你的代码缓存mbuf比较多，这里就需要设置大一些，防止不够用</li>
<li>cache_size：mp里面cache的数量</li>
<li>priv_size：每一个mbuf私有数据空间的大小，不需要直接设置为0即可</li>
<li>data_room_size：mbuf的数据报文的大小，理论上需要加上room head的大小，建议使用默认值，默认2048+128 RTE_MBUF_DEFAULT_BUF_SIZE</li>
<li>socket_id：申请内存的socket，不清楚设置那个的直接使用rte_socket_id()即可</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">rte_eth_dev_configure</span><span class="params">(<span class="keyword">uint16_t</span> port_id, <span class="keyword">uint16_t</span> nb_rx_q, <span class="keyword">uint16_t</span> nb_tx_q,</span></span></span><br><span class="line"><span class="params"><span class="function">		      <span class="keyword">const</span> struct rte_eth_conf *dev_conf)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>port_id：设备的port_id</li>
<li>nb_rx_q：收队列数</li>
<li>nb_tx_q：发送队列数</li>
<li>dev_conf：设备相关信息，如收发模式和速率等</li>
</ul>
<blockquote>
<p>配置网卡，包括网卡收包大小，网卡队列，端口和队列关联</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">rte_eth_rx_queue_setup</span><span class="params">(<span class="keyword">uint16_t</span> port_id, <span class="keyword">uint16_t</span> rx_queue_id,</span></span></span><br><span class="line"><span class="params"><span class="function">		       <span class="keyword">uint16_t</span> nb_rx_desc, <span class="keyword">unsigned</span> <span class="keyword">int</span> socket_id,</span></span></span><br><span class="line"><span class="params"><span class="function">		       <span class="keyword">const</span> struct rte_eth_rxconf *rx_conf,</span></span></span><br><span class="line"><span class="params"><span class="function">		       struct rte_mempool *mp)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>port_id：设备的port_id</li>
<li>rx_queue_id：队列号，存在多个队列要每个都设置</li>
<li>nb_rx_desc：设置队列的接收描述符(desc)的个数，也决定这接收队列的大小</li>
<li>socket_id：numa架构下的socket id</li>
<li>rx_conf：接收配置文件，如释放和回写的阈值等，为NULL就采用默认配置文件。</li>
<li>rte_mempool：指向内存池的指针，从中分配网络内存缓冲区以填充接收环的每个描述符。</li>
</ul>
<blockquote>
<p>发送和接收一致</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint16_t</span></span></span><br><span class="line"><span class="function"><span class="title">rte_eth_rx_burst</span><span class="params">(<span class="keyword">uint16_t</span> port_id, <span class="keyword">uint16_t</span> queue_id,</span></span></span><br><span class="line"><span class="params"><span class="function">		 struct rte_mbuf **rx_pkts, <span class="keyword">const</span> <span class="keyword">uint16_t</span> nb_pkts)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint16_t</span></span></span><br><span class="line"><span class="function"><span class="title">rte_eth_tx_burst</span><span class="params">(<span class="keyword">uint16_t</span> port_id, <span class="keyword">uint16_t</span> queue_id,</span></span></span><br><span class="line"><span class="params"><span class="function">		 struct rte_mbuf **tx_pkts, <span class="keyword">const</span> <span class="keyword">uint16_t</span> nb_pkts)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>port_id：设备的port_id</li>
<li>queue_id：队列号</li>
<li>rx_pkts：指针数组的地址，指向包的地址,必须大于nb_pkts</li>
<li>nb_pkts：取回的数据包最大个数。该值必须可分解为8的倍数，以便与任何驱动程序合作。</li>
</ul>
<h3 id="l3fwd"><a href="#l3fwd" class="headerlink" title="l3fwd"></a>l3fwd</h3><h1 id="Cache和内存"><a href="#Cache和内存" class="headerlink" title="Cache和内存"></a>Cache和内存</h1><h2 id="存储系统简介"><a href="#存储系统简介" class="headerlink" title="存储系统简介"></a>存储系统简介</h2><p>存储系统：磁盘、磁带、光盘存储器、内存和CPU内部的Cache。</p>
<h3 id="系统架构演进"><a href="#系统架构演进" class="headerlink" title="系统架构演进"></a>系统架构演进</h3><p>早期的计算机，内存控制器还没有整合进 CPU，所有的内存访问都需要经过北桥芯片来完成。如下图所示，CPU 通过前端总线（FSB，Front Side Bus）连接到北桥芯片，然后北桥芯片连接到内存——内存控制器集成在北桥芯片里面。</p>
<p><img src="/2022/04/10/dpdk%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/cpu_fsb.jpg"></p>
<blockquote>
<p>这种架构下cpu无论访问内存，设备，同时处理器之间的交换都要通过北桥，北桥成为系统瓶颈</p>
</blockquote>
<p>实际上现在架构中，CPU中涵盖了内存控制器，因此CPU和内存就是直连的。</p>
<blockquote>
<p>CPU直连的设备通常有: PCIE、DRAM、QPI(numa架构下访问远端内存需要的，实际上QPI是FSB的一种替代方案，提供了更快的传输速率)</p>
</blockquote>
<p>但是这种架构不同cpu逻辑核访问的都是同一块内存，因此称为UMA(一致性内存访问)，总线模型保证了所有内存访问的都是一致的，不必考虑不同内存地址之间的差距。</p>
<blockquote>
<p>在这种场景下，提升性能的方案就是，提升CPU频率，DRAM频率，和”FSB”(QPI)总线的传输速率。实际上CPU主频已经存在物理瓶颈，无法再通过提升主频提升效率，后面就是开始堆核，然后开始多CPU插槽</p>
</blockquote>
<blockquote>
<p>作者注：dpdk涉及的知识体系庞大，深入理解dpdk的原理目前欠缺的知识体系较多，基础不牢地动山摇，只能一点点去补基础知识：1、计算机组成原理 （）2、操作系统 3、计算机系统基础 </p>
</blockquote>

	
	</div>
  <a type="button" href="/2022/04/10/dpdk深入浅出/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/03/25/mtu/" >mtu</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-03-25  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h1 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h1><p>Maximum Transmission Unit 最大传输单元。</p>
<p>不同链路介质对网络有不同的默认MTU值，以下是一些常见的默认值:</p>
<p><img src="/2022/03/25/mtu/frame_mtu.png"></p>
<p>以太网MTU通常被设置为1500。</p>
<h2 id="为什么以太网帧mtu被设为1500"><a href="#为什么以太网帧mtu被设为1500" class="headerlink" title="为什么以太网帧mtu被设为1500"></a>为什么以太网帧mtu被设为1500</h2><p>早期的以太网使用共享链路的工作方式，为了保证CSMA&#x2F;CD（载波多路复用&#x2F;冲突检测）机制，所以规定了以太帧长度最小为64字节，最大为1518字节。最小64字节是为了保证最极端的冲突能被检测到，64字节是能被检测到的最小值；最大不超过1518字节是为了防止过长的帧传输时间过长而占用共享链路太长时间导致其他业务阻塞。所以规定以太网帧大小为64~1518字节，虽然技术不断发展，但协议一直没有更改。</p>
<p>以太网最大的数据帧是1518字节，这样刨去帧头14字节和帧尾CRC校验部分4字节，那么剩下承载上层IP报文的地方最大就只有1500字节，这个值就是以太网的默认MTU值。这个MTU就是网络层协议非常关心的地方，因为网络层协议比如IP协议会根据这个值来决定是否把上层传下来的数据进行分片，如果单个IP报文长度大于MTU，则会在发送出接口前被分片，被切割为小于或等于MTU长度的IP包。</p>
<blockquote>
<p>其实不同厂商对于MTU的定义略有不同，常见的是MTU为IP包的最大长度，如cisco，MTU是指的IP+以太网帧头部，还有的MTU&#x3D;IP+以太网帧头部+CRC</p>
</blockquote>
<h2 id="MTU划分的帧格式"><a href="#MTU划分的帧格式" class="headerlink" title="MTU划分的帧格式"></a>MTU划分的帧格式</h2><p><img src="/2022/03/25/mtu/frame.png"></p>
<h2 id="Jumbo帧与MTU"><a href="#Jumbo帧与MTU" class="headerlink" title="Jumbo帧与MTU"></a>Jumbo帧与MTU</h2><blockquote>
<p>帧过小，导致帧的利用率过小，同时增加分片开销，帧过大，如果丢包导致大量数据重传浪费资源</p>
</blockquote>
<p>由于现在场景已由计算密集型转变为IO密集型，大量的网络数据需要进行分片，每个数据包都需要网络设备来进行处理，由此带来的额外开销也将很大，而且这个开销随着网络速度的提高而愈加明显。</p>
<p>于是一些厂商提出了巨型帧（Jumbo Frame）的概念，把以太网的最大帧长扩展到了9K，相当于增强版的MTU，区别在于：</p>
<ul>
<li>jumbo帧是在数据链路层处理的，MTU涉及的分片通常是在网络层进行的</li>
<li>jumbo帧包括二层以太网帧头和CRC部分，MTU一般不包括这部分，通常是指三层IP报文的长度。</li>
</ul>
<p>加大帧长的好处在于，减少了网络中数据包的个数，减轻了网络设备处理包头的额外开销。大量减少的帧数目也带来了性能的提高。</p>
<h2 id="TCP-MSS和MTU"><a href="#TCP-MSS和MTU" class="headerlink" title="TCP MSS和MTU"></a>TCP MSS和MTU</h2><p>TCP MSS（Maximum Segment Size）是指TCP协议所允许的从对方收到的最大报文长度，即TCP数据包每次能够传输的最大数据分段，只包含TCP Payload，不包含TCP Header和TCP Option。MSS是TCP用来限制application层最大的发送字节数。为了达到最佳的传输效能，TCP协议在建立连接的时候通常要协商双方的MSS值，这个值TCP协议在实现的时候往往根据MTU值来计算（需要减去IP包头20字节和TCP包头20字节），所以通常MSS为1460&#x3D;1500(MTU)- 20(IP Header) -20 (TCP Header)。</p>
<p><img src="/2022/03/25/mtu/mss.png"></p>
<h2 id="Path-MTU"><a href="#Path-MTU" class="headerlink" title="Path MTU"></a>Path MTU</h2><blockquote>
<p>简单来说就是路径上最小的MTU作为这条链路的MTU<br>路径MTU的探测，<br>UDP和TCP通过ICMP实现，ICMP会回复type为3code为4的差错报文，表示需要分片，但是IP包的DF已设置，导致报文不可达被丢弃，而在icmp回复的报文中会存在下一跳的的MTU值，即PATHMTUDiscovery。</p>
</blockquote>
<ol>
<li>如果主机本地链路的MTU大于端到端链路中某一点的MTU值，那么这个数据包因为有DF&#x3D;1的原因，会被丢弃。</li>
<li>如果路由器本地链路的MTU为整个端到端链路中最小值时，数据包很幸运的被送达目的地。</li>
</ol>
<p>对于1，路由器会回复icmp差错报文，同时在差错报文中携带了此路由器的下一跳MTU值。（Destination unreachable(fragmentation needed)），从而调整MTU值。</p>
<p><img src="/2022/03/25/mtu/PathMTU_Discovery.png"></p>
<blockquote>
<p>tcp协议栈会根据路由器回复的icmp报文动态调整mss，实际上处于安全考虑并不是所有的路由器都会回复icmp报文，如果此时没有收到任何icmp报文，tcp会在超时重传后修改mss的值为更小的值。上述的一切基于tcp开启mtu_probing实现</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 默认关闭</span></span><br><span class="line">[root@giddypoet ~]# cat /proc/sys/net/ipv4/tcp_mtu_probing </span><br><span class="line">0</span><br></pre></td></tr></table></figure>
	
	</div>
  <a type="button" href="/2022/03/25/mtu/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/03/16/linux-start-process/" >linux_start_process</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-03-16  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		
	
	</div>
  <a type="button" href="/2022/03/16/linux-start-process/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/03/15/tcp-cookies/" >tcp_syncookies</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-03-15  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h1 id="tcp-syncookies"><a href="#tcp-syncookies" class="headerlink" title="tcp_syncookies"></a>tcp_syncookies</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>需要对设备进行synflood测试，验证syn_cookies功能是否正常。</p>
<h2 id="syncookies原理"><a href="#syncookies原理" class="headerlink" title="syncookies原理"></a>syncookies原理</h2><p>SYN Cookie是对TCP服务器端的三次握手做一些修改，专门用来防范SYN Flood攻击的一种手段。它的原理是，在TCP服务器接收到TCP SYN包并返回TCP SYN + ACK包时，不分配一个专门的数据区，而是根据这个SYN包计算出一个cookie值。这个cookie作为将要返回的SYN ACK包的初始序列号。</p>
<blockquote>
<p>syncookies复用seqnum字段，前5个bits是简易版本的时间戳，中间3个bits是mss值，后面24个是散列值。</p>
</blockquote>
<p>seqnum的构造</p>
<ul>
<li>设t为一个缓慢增长的时间戳，前5个bits</li>
<li>设m为客户端发送的syn报文中的mss值，3个bits</li>
<li>设s是连接的元组信息（源IP，目的IP，源端口，目的端口）和t的hash值，即&#96;s&#x3D;hash(sip,dip,sport,dport,t)，s取低24位</li>
</ul>
<p>当客户端收到携带这个seqnum的值，则会恢复ack报文，且报文中ack&#x3D;n+1，那么在服务器收到它时，将ack-1即可拿到原始序列号，通过这种方式保存了syn报文的信息。</p>
<p>对ack报文检查</p>
<ul>
<li>高5位表示的t与当前时间比较，看是否在时间范围内</li>
<li>将t和连接元组重新计算s，看是否和低24位一直，若不一致则说明报文被伪造</li>
<li>解析出其中的mss信息</li>
</ul>
<h3 id="syncookies的缺点"><a href="#syncookies的缺点" class="headerlink" title="syncookies的缺点"></a>syncookies的缺点</h3><ol>
<li>mss的编码只有3位，因此最多只有8种mss值</li>
<li>丢失大部分syn option（这里如果服务器和客户端都开起了时间戳ts，可以通过这ts里携带syn option，携带wscale，sack，ecn）</li>
<li>增加了hash运算的开销</li>
</ol>
<h3 id="syncookies的实现"><a href="#syncookies的实现" class="headerlink" title="syncookies的实现"></a>syncookies的实现</h3><p>linux内核实现syncookies的算法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seq = hash(saddr, daddr, sport, dport, <span class="number">0</span>, <span class="number">0</span>) + req.th.seq + t &lt;&lt; <span class="number">24</span> + (hash(saddr, daddr, sport, dport, t, <span class="number">1</span>) + mss_ind) &amp; <span class="number">0x00FFFFFF</span></span><br></pre></td></tr></table></figure>


<h2 id="内核相关配置"><a href="#内核相关配置" class="headerlink" title="内核相关配置"></a>内核相关配置</h2><p>开启syncookies的条件是，设置了syncookies，并且在服务器的accept_queue满载时才会启用。</p>
<blockquote>
<p>简单来说即便开启了syncookies，当accept_queue不满载的时候也不触发</p>
</blockquote>
<p>那么这个accept_queue这个阈值是多少呢？这就涉及到linux的内核设计，linux将tcp连接分为两种：</p>
<ul>
<li>全连接，ESTABLISHED的连接属于全连接，在全连接队列中</li>
<li>半连接，接收到syn包进入syn-recv状态后，即加入半连接队列</li>
</ul>
<p>accept_queue即半连接队列。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 半连接队列大小</span></span><br><span class="line">[root@version ~]# cat /proc/sys/net/ipv4/tcp_max_syn_backlog </span><br><span class="line">128</span><br><span class="line"><span class="meta">#</span><span class="bash"> syncookies开关</span></span><br><span class="line">[root@version ~]# cat /proc/sys/net/ipv4/tcp_syncookies </span><br><span class="line">1</span><br></pre></td></tr></table></figure>

	
	</div>
  <a type="button" href="/2022/03/15/tcp-cookies/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/02/22/killcx/" >killcx</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-02-22  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h1 id="killcx"><a href="#killcx" class="headerlink" title="killcx"></a>killcx</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>今天在逛博客的时候发现一个有意思的问题：</p>
<pre><code>如何在不是同一个进程的情况下，关闭一个TCP连接？
</code></pre>
<p>通常我们可以想到的关闭一个连接的方法如下：</p>
<ol>
<li>进程内close（通用文件描述符关闭方法）</li>
<li>进程内shutdown（可以半关闭socket，专门为socket定制）</li>
<li>回RST报文</li>
<li>内核回调？等奇技淫巧这里就不讨论了</li>
</ol>
<p>但是1和2的方式都必须在同一个进程内实现，因此不满足问题的要求，所以应该就是回RST报文，实际上这也是防火墙或者一些旁路设备常的事情，有些VPN也会构造类似的请求，来阻止不合法的连接。</p>
<p>那么既然我们知道需要怎么做，那怎么构造一个合法的RST报文就是一个问题。</p>
<h2 id="合法的RST报文"><a href="#合法的RST报文" class="headerlink" title="合法的RST报文"></a>合法的RST报文</h2><p>合法的RST报文需要的条件：</p>
<ol>
<li>四元组</li>
<li>正确的序列号</li>
</ol>
<!-- 正确的时间戳（这个需要开启/proc/sys/net/ipv4/tcp_timestamps） 这个需要确认下源码是否对时间戳进行了检查-->

<p>上述信息通常可以由旁路设备获得（旁路设备通过侦听链路上的报文就可以获得），VPN防火墙也可以通过连接获得，那么第三方进程如何构造正确的RST报文呢？</p>
<p>可以通过challenge ACK实现，原理如下：</p>
<blockquote>
<p>处于 establish 状态的服务端如果收到了客户端的 SYN 报文（注意此时的 SYN 报文其实是乱序的，因为 SYN 报文的初始化序列号其实是一个随机数），会回复一个携带了正确序列号和确认号的 ACK 报文，这个 ACK 被称之为 Challenge ACK。</p>
</blockquote>
<blockquote>
<p>实际上部分防火墙和nat设备并不支持challenge ACK</p>
</blockquote>
<p>那么我们就可以通过raw socket进行构造乱序的SYN包，再通过服务端回的正确的ACK获取到序列号，再回复RST报文。</p>
<p><img src="/2022/02/22/killcx/challenge_ack.jpg"></p>
<p>其实有现成的工具就可以实现上述功能，killcx是一款基于perl实现的脚本工具，下面将对killcx进行简单的分析。</p>
<h2 id="killcx分析"><a href="#killcx分析" class="headerlink" title="killcx分析"></a>killcx分析</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> strict; </span><br><span class="line"><span class="keyword">use</span> Socket; </span><br><span class="line"><span class="keyword">use</span> Net::RawIP;</span><br><span class="line"><span class="keyword">use</span> Net::Pcap;</span><br><span class="line"><span class="keyword">use</span> NetPacket::Ethernet <span class="string">qw(:strip)</span>;</span><br><span class="line"><span class="keyword">use</span> NetPacket::IP <span class="string">qw(:strip)</span>;</span><br><span class="line"><span class="keyword">use</span> NetPacket::TCP;</span><br><span class="line"><span class="keyword">use</span> POSIX <span class="string">qw(setsid)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> $appname = <span class="string">&#x27;killcx&#x27;</span>;</span><br><span class="line"><span class="keyword">my</span> $version = <span class="string">&#x27;v1.0.3&#x27;</span>;</span><br><span class="line"><span class="keyword">my</span> $copyright = <span class="string">&#x27;(c)2009-2011 Jerome Bruandet - http://killcx.sourceforge.net/&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;$appname $version - $copyright\n\n&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> ( $&gt; ) &#123;</span><br><span class="line">   <span class="keyword">print</span> <span class="string">&quot;\t[ERROR] : you must be root\n\n&quot;</span>;</span><br><span class="line">   <span class="keyword">exit</span> <span class="number">1</span>; </span><br><span class="line">&#125; <span class="keyword">elsif</span> ( $^O <span class="keyword">ne</span> <span class="string">&#x27;linux&#x27;</span> )&#123;</span><br><span class="line">   <span class="keyword">print</span> <span class="string">&quot;\t[ERROR] : that script is for Linux only, not $^O\n\n&quot;</span>;</span><br><span class="line">   <span class="keyword">exit</span> <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line">$SIG<span class="string">&#123;USR1&#125;</span> = \&amp;check_res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> ( $dest_ip, $dest_port ) =</span><br><span class="line">   $ARGV[<span class="number">0</span>] =~ <span class="regexp">/^(\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;):(\d+)$/</span>;</span><br><span class="line"><span class="keyword">my</span> $interface = $ARGV[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( ( ! $dest_ip ) || ( ! $dest_port ) ) &#123;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;- syntax   : $appname &lt;destip:destport&gt; &lt;interface&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  destip               : remote IP</span></span><br><span class="line"><span class="string">  destport             : remote port</span></span><br><span class="line"><span class="string">  interface (optional) : network interface (eth0, lo etc). Note that</span></span><br><span class="line"><span class="string">                         in many cases, using &#x27;lo&#x27; (loopback) will give</span></span><br><span class="line"><span class="string">                         better results, specially when a connection</span></span><br><span class="line"><span class="string">                         is not yet or no longer in the ESTABLISHED state</span></span><br><span class="line"><span class="string">                         (SYN_RECV, TIME_WAIT etc).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- example  : $appname 10.11.12.13:1234</span></span><br><span class="line"><span class="string">             $appname 10.11.12.13:1234 eth0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- doc      :  http://killcx.sourceforge.net/</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>;</span><br><span class="line">   <span class="keyword">exit</span> <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> $pid = $$;</span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> %TCP_STATES = (</span><br><span class="line"><span class="string">&#x27;01&#x27;</span> =&gt; <span class="string">&#x27;ESTABLISHED&#x27;</span>, <span class="string">&#x27;02&#x27;</span> =&gt; <span class="string">&#x27;SYN_SENT&#x27;</span>,  <span class="string">&#x27;03&#x27;</span> =&gt; <span class="string">&#x27;SYN_RECV&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;04&#x27;</span> =&gt; <span class="string">&#x27;FIN_WAIT1&#x27;</span>,   <span class="string">&#x27;05&#x27;</span> =&gt; <span class="string">&#x27;FIN_WAIT2&#x27;</span>, <span class="string">&#x27;06&#x27;</span> =&gt; <span class="string">&#x27;TIME_WAIT&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;07&#x27;</span> =&gt; <span class="string">&#x27;CLOSE&#x27;</span>,       <span class="string">&#x27;08&#x27;</span> =&gt; <span class="string">&#x27;CLOSE_WAIT&#x27;</span>,<span class="string">&#x27;09&#x27;</span> =&gt; <span class="string">&#x27;LAST_ACK&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;0A&#x27;</span> =&gt; <span class="string">&#x27;LISTEN&#x27;</span>,      <span class="string">&#x27;0B&#x27;</span> =&gt; <span class="string">&#x27;CLOSING&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment"># convert to network byte order :</span></span><br><span class="line">$dest_ip =~ <span class="regexp">/^(\d&#123;1,3&#125;)\.(\d&#123;1,3&#125;)\.(\d&#123;1,3&#125;)\.(\d&#123;1,3&#125;)$/</span>;</span><br><span class="line"><span class="keyword">my</span> $dest_hex = <span class="keyword">sprintf</span> <span class="string">&quot;%.2X%.2X%.2X%.2X:%.4X&quot;</span>,$4,$3,$2,$1,$dest_port;</span><br><span class="line"><span class="comment"># check in /proc/net/tcp :</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;[PARENT] checking connection with [$dest_ip:$dest_port]\n&quot;</span>;</span><br><span class="line"><span class="keyword">my</span> ( $local_ip, $local_port, $state) = &amp;check_tcp( $dest_hex );</span><br><span class="line"><span class="keyword">if</span> ( ! $state ) &#123;</span><br><span class="line">   <span class="keyword">print</span> <span class="string">&quot;[PARENT] error : unable to find a connection with &quot;</span>.</span><br><span class="line">      <span class="string">&quot;[$dest_ip:$dest_port]\n\n&quot;</span>;</span><br><span class="line">   <span class="keyword">exit</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;[PARENT] found connection with [$local_ip:$local_port] &quot;</span>.</span><br><span class="line">   <span class="string">&quot;($TCP_STATES&#123;$state&#125;)\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># fork our child which will hook the server response to our spoofed</span></span><br><span class="line"><span class="comment"># packet and extract the correct acknum (and seqnum) needed to close</span></span><br><span class="line"><span class="comment"># the connection :</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;[PARENT] forking child\n&quot;</span>;</span><br><span class="line"><span class="keyword">use</span> POSIX <span class="string">&#x27;WNOHANG&#x27;</span>;</span><br><span class="line">$SIG<span class="string">&#123;CHLD&#125;</span> = <span class="function"><span class="keyword">sub</span> </span>&#123; <span class="keyword">while</span>( <span class="keyword">waitpid</span>( -<span class="number">1</span>,WNOHANG ) &gt; <span class="number">0</span> ) &#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">defined</span> ( <span class="keyword">my</span> $child_pid = <span class="keyword">fork</span> ) <span class="keyword">or</span></span><br><span class="line">   <span class="keyword">die</span> <span class="string">&quot;[PARENT] error : cannot fork : $!\n&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> ( $child_pid == <span class="number">0</span> ) &#123;</span><br><span class="line">   setsid <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">&quot;[CHILD]  error : cannot setid : $!&quot;</span>;</span><br><span class="line">   <span class="keyword">my</span> ($err, $filter, $netmask, $address, $pcap);</span><br><span class="line"></span><br><span class="line">   <span class="comment"># no interface given, let&#x27;s try to find one :</span></span><br><span class="line">   <span class="keyword">if</span> ( ! $interface ) &#123;</span><br><span class="line">      $interface = Net::Pcap::lookupdev( \$err );</span><br><span class="line">      <span class="keyword">print</span> <span class="string">&quot;[CHILD]  &quot;</span>;</span><br><span class="line">      <span class="keyword">if</span> ( $interface ) &#123;</span><br><span class="line">         <span class="keyword">print</span> <span class="string">&quot;interface not defined, will use [$interface]\n&quot;</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment"># switch to loopback if we can&#x27;t find any interface :</span></span><br><span class="line">         <span class="keyword">print</span> <span class="string">&quot;no interface found, switching to loopback\n&quot;</span>;</span><br><span class="line">         $interface = <span class="string">&#x27;lo&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment"># let&#x27;s sniff :</span></span><br><span class="line">   <span class="keyword">print</span> <span class="string">&quot;[CHILD]  setting up filter to sniff ACK on [$interface]&quot;</span>.</span><br><span class="line">      <span class="string">&quot; for 5 seconds\n&quot;</span>;</span><br><span class="line">   <span class="keyword">my</span> $pcap = Net::Pcap::open_live( $interface, <span class="number">100</span>, <span class="number">1</span>, <span class="number">5000</span>, \$err) ||</span><br><span class="line">      <span class="keyword">die</span> <span class="string">&quot;[CHILD]  error : open_live failed : $err\n&quot;</span>;</span><br><span class="line">   <span class="comment"># setup filter :</span></span><br><span class="line">   Net::Pcap::compile( $pcap, \$filter,</span><br><span class="line">      <span class="string">&quot;(dst port $dest_port) &amp;&amp; (src port $local_port)&quot;</span>,</span><br><span class="line">      <span class="number">0</span>, $netmask) &amp;&amp;</span><br><span class="line">      <span class="keyword">die</span> <span class="string">&quot;[CHILD]  error : compile failed : $!\n&quot;</span>;</span><br><span class="line">   Net::Pcap::setfilter($pcap, $filter) &amp;&amp;</span><br><span class="line">      <span class="keyword">die</span> <span class="string">&quot;[CHILD]  error : setfilter failed : $!\n&quot;</span>;</span><br><span class="line">   <span class="comment"># only want to hook 1 packet :</span></span><br><span class="line">   Net::Pcap::loop($pcap, <span class="number">1</span> , \&amp;process_packet, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">   Net::Pcap::<span class="keyword">close</span>($pcap);</span><br><span class="line">   <span class="comment"># all done, let&#x27;s inform our parent :</span></span><br><span class="line">   <span class="keyword">print</span> <span class="string">&quot;[CHILD]  all done, sending USR1 signal to parent [$pid] &quot;</span>.</span><br><span class="line">      <span class="string">&quot;and exiting\n&quot;</span>;</span><br><span class="line">   <span class="string">`kill -s USR1 $pid`</span>;</span><br><span class="line">   <span class="keyword">exit</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># wait 0.5 second for our child to be ready :</span></span><br><span class="line"><span class="keyword">select</span>( <span class="keyword">undef</span>, <span class="keyword">undef</span>, <span class="keyword">undef</span>, <span class="number">0</span>.<span class="number">5</span> );</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;[PARENT] sending spoofed SYN to [$local_ip:$local_port]&quot;</span>.</span><br><span class="line">   <span class="string">&quot; with bogus SeqNum\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># send spoofed SYN packet :</span></span><br><span class="line"><span class="keyword">my</span> $packet = Net::RawIP-&gt;new(&#123;</span><br><span class="line">      <span class="string">ip =&gt;</span> &#123;  <span class="string">frag_off =&gt;</span> <span class="number">0</span>, <span class="string">tos =&gt;</span> <span class="number">0</span>,</span><br><span class="line">               <span class="string">saddr =&gt;</span> $dest_ip, <span class="string">daddr =&gt;</span> $local_ip</span><br><span class="line">            &#125;,</span><br><span class="line">      <span class="string">tcp =&gt;</span>&#123;  <span class="string">dest =&gt;</span> $local_port, <span class="string">source =&gt;</span> $dest_port,</span><br><span class="line">               <span class="string">seq =&gt;</span> <span class="number">10</span>, <span class="string">syn =&gt;</span> <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   $packet-&gt;<span class="keyword">send</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># wait max 5 seconds :</span></span><br><span class="line"><span class="keyword">select</span>( <span class="keyword">undef</span>, <span class="keyword">undef</span>, <span class="keyword">undef</span>, <span class="number">5</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment"># didn&#x27;t receive any signal from our child, it has probably failed :</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;[PARENT] no response from child, operation may have failed\n&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> ( $interface <span class="keyword">ne</span> <span class="string">&#x27;lo&#x27;</span> ) &#123;</span><br><span class="line">   <span class="keyword">print</span> <span class="string">&quot;[PARENT] =&gt; you may try using &#x27;lo&#x27; as interface parameter\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;[PARENT] killing child [$child_pid] and exiting program\n\n&quot;</span>;</span><br><span class="line"><span class="comment"># kill it and exit :</span></span><br><span class="line"><span class="keyword">kill</span> <span class="number">9</span>, $child_pid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">exit</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">######################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">check_res</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment"># received signal from our child :</span></span><br><span class="line">   <span class="keyword">print</span> <span class="string">&quot;[PARENT] received child signal, checking results...\n&quot;</span>;</span><br><span class="line">   <span class="comment"># check whether the operation was successful or not :</span></span><br><span class="line">   ( $local_ip, $local_port, $state) = &amp;check_tcp( $dest_hex );</span><br><span class="line">   <span class="keyword">if</span> ( $state ) &#123;</span><br><span class="line">   <span class="keyword">print</span> <span class="string">&quot;         =&gt; error : connection hasn&#x27;t been closed\n\n&quot;</span>;</span><br><span class="line">      <span class="keyword">exit</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">print</span> <span class="string">&quot;         =&gt; success : connection has been closed !\n\n&quot;</span>;</span><br><span class="line">   <span class="keyword">exit</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">######################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">process_packet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">my</span>( $user_data, $header, $packet ) = @_;</span><br><span class="line">   <span class="keyword">my</span> $ether_data = NetPacket::Ethernet::strip($packet);</span><br><span class="line"></span><br><span class="line">   <span class="comment"># decode TCP/IP packet (server response to our spoofed packet) :</span></span><br><span class="line">   <span class="keyword">my</span> $ip = NetPacket::IP-&gt;decode($ether_data);</span><br><span class="line">   <span class="keyword">my</span> $tcp = NetPacket::TCP-&gt;decode($ip-&gt;&#123;<span class="string">&#x27;data&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">print</span> <span class="string">&quot;[CHILD]  hooked ACK from [$local_ip:$local_port]\n&quot;</span>;</span><br><span class="line">   <span class="comment"># look for the magic acknum :</span></span><br><span class="line">   <span class="keyword">print</span> <span class="string">&quot;[CHILD]  &quot;</span>;</span><br><span class="line">   <span class="keyword">if</span> ( $tcp-&gt;&#123;acknum&#125; ) &#123;</span><br><span class="line">      <span class="keyword">print</span> <span class="string">&quot;found AckNum [$tcp-&gt;&#123;acknum&#125;] and SeqNum &quot;</span>.</span><br><span class="line">         <span class="string">&quot;[$tcp-&gt;&#123;seqnum&#125;]\n&quot;</span>;</span><br><span class="line">      <span class="keyword">print</span> <span class="string">&quot;[CHILD]  sending spoofed RST to [$local_ip:$local_port]&quot;</span>.</span><br><span class="line">         <span class="string">&quot; with SeqNum [$tcp-&gt;&#123;acknum&#125;]\n&quot;</span>;</span><br><span class="line">      <span class="comment"># we have it : spoof another packet (RST) with the correct seqnum</span></span><br><span class="line">      <span class="comment"># to close the connection :</span></span><br><span class="line">      <span class="keyword">my</span> $packet = Net::RawIP-&gt;new( &#123;</span><br><span class="line">         <span class="string">ip =&gt;</span> &#123;  <span class="string">frag_off =&gt;</span> <span class="number">0</span>, <span class="string">tos =&gt;</span> <span class="number">0</span>,</span><br><span class="line">                  <span class="string">saddr =&gt;</span> $dest_ip, <span class="string">daddr =&gt;</span> $local_ip</span><br><span class="line">               &#125;,</span><br><span class="line">         <span class="string">tcp =&gt;</span>&#123;  <span class="string">dest =&gt;</span> $local_port, <span class="string">source =&gt;</span> $dest_port,</span><br><span class="line">                  <span class="string">seq =&gt;</span> $tcp-&gt;&#123;acknum&#125;, <span class="string">rst =&gt;</span> <span class="number">1</span></span><br><span class="line">               &#125;</span><br><span class="line">      &#125; );</span><br><span class="line">         $packet-&gt;<span class="keyword">send</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment"># if the connection was in the ESTABLISHED state we close it</span></span><br><span class="line">      <span class="comment"># with the remote host as well, otherwise we don&#x27;t care</span></span><br><span class="line">      <span class="comment"># (the server would reply with a RST packet anyway) :</span></span><br><span class="line">      <span class="keyword">if</span> ( $state == <span class="number">1</span> ) &#123;</span><br><span class="line">         <span class="keyword">print</span> <span class="string">&quot;[CHILD]  sending RST &quot;</span>.</span><br><span class="line">            <span class="string">&quot;to remote host as well with SeqNum [$tcp-&gt;&#123;seqnum&#125;]\n&quot;</span>;</span><br><span class="line">         <span class="keyword">my</span> $packet = Net::RawIP-&gt;new( &#123;</span><br><span class="line">         <span class="string">ip =&gt;</span> &#123;  <span class="string">frag_off =&gt;</span> <span class="number">0</span>, <span class="string">tos =&gt;</span> <span class="number">0</span>,</span><br><span class="line">                  <span class="string">saddr =&gt;</span> $local_ip, <span class="string">daddr =&gt;</span> $dest_ip</span><br><span class="line">               &#125;,</span><br><span class="line">         <span class="string">tcp =&gt;</span>&#123;  <span class="string">dest =&gt;</span> $dest_port, <span class="string">source =&gt;</span> $local_port,</span><br><span class="line">                  <span class="string">seq =&gt;</span> $tcp-&gt;&#123;seqnum&#125;, <span class="string">rst =&gt;</span> <span class="number">1</span></span><br><span class="line">               &#125;</span><br><span class="line">         &#125; );</span><br><span class="line">         $packet-&gt;<span class="keyword">send</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment"># very unlikely to happen (ACK packets always have acknum) :</span></span><br><span class="line">      <span class="keyword">print</span> <span class="string">&quot;error : no AckNum found in packet\n&quot;</span>;</span><br><span class="line">      <span class="keyword">exit</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">######################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">check_tcp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">my</span> $hex_rem = <span class="keyword">shift</span>;</span><br><span class="line">   <span class="keyword">my</span> ( $li, $lp, $st );</span><br><span class="line">   <span class="keyword">open</span> TCP, <span class="string">&quot;&lt;/proc/net/tcp&quot;</span>;</span><br><span class="line">   <span class="keyword">while</span> ( &lt;TCP&gt; ) &#123;</span><br><span class="line">      <span class="keyword">if</span> ( <span class="regexp">/^\s*\d+:\s+(.&#123;8&#125;):(.&#123;4&#125;)\s+$hex_rem\s+(.&#123;2&#125;)\s/</span> ) &#123;</span><br><span class="line">         $st = $3;</span><br><span class="line">         $lp = <span class="keyword">hex</span>( $2 );</span><br><span class="line">         ($li) = $1 =~ <span class="regexp">/(.&#123;2&#125;)(.&#123;2&#125;)(.&#123;2&#125;)(.&#123;2&#125;)/</span>;</span><br><span class="line">         $li = inet_ntoa( <span class="keyword">pack</span>(<span class="string">&quot;N&quot;</span>, <span class="keyword">hex</span>( $4.$3.$2.$1 ) ) );</span><br><span class="line">         <span class="keyword">last</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">close</span> TCP;</span><br><span class="line">   <span class="comment"># if not found, check /proc/net/tcp6 :</span></span><br><span class="line">   <span class="keyword">if</span> ( ( ! $st ) &amp;&amp; ( -e <span class="string">&#x27;/proc/net/tcp6&#x27;</span> ) ) &#123;</span><br><span class="line">      <span class="keyword">open</span> TCP, <span class="string">&quot;&lt;/proc/net/tcp6&quot;</span>;</span><br><span class="line">      <span class="keyword">while</span> ( &lt;TCP&gt; ) &#123;</span><br><span class="line">         <span class="keyword">if</span> ( <span class="regexp">/^\s*\d+:\s+\d&#123;16&#125;FFFF0000(.&#123;8&#125;):(.&#123;4&#125;)\s+</span></span><br><span class="line"><span class="regexp">               \d&#123;16&#125;FFFF0000$hex_rem\s+(.&#123;2&#125;)\s/x</span> ) &#123;</span><br><span class="line">            $st = $3;</span><br><span class="line">            $lp = <span class="keyword">hex</span>( $2 );</span><br><span class="line">            ($li) = $1 =~ <span class="regexp">/(.&#123;2&#125;)(.&#123;2&#125;)(.&#123;2&#125;)(.&#123;2&#125;)/</span>;</span><br><span class="line">            $li = inet_ntoa( <span class="keyword">pack</span>(<span class="string">&quot;N&quot;</span>, <span class="keyword">hex</span>( $4.$3.$2.$1 ) ) );</span><br><span class="line">            <span class="keyword">last</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">close</span> TCP;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ( $li, $lp, $st );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">######################################################################</span></span><br><span class="line"><span class="comment"># EOF</span></span><br></pre></td></tr></table></figure>


<ol>
<li>首先通过输入的目的IP和端口，在<code>/proc/net/tcp</code>中查找连接状态，其中IP为网络字节序，并且16进制表示，连接状态为0A（Establish）之类的形式。</li>
<li>通过raw socket构造syn包，seq num为10（一个随机值即可）</li>
<li>子进程同时调用pcap抓包，用于获取challenge ack的响应中的seqnum</li>
<li>用响应中的seqnum构造RST报文</li>
<li>最后确认下链接是否被关闭</li>
</ol>

	
	</div>
  <a type="button" href="/2022/02/22/killcx/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/02/08/linux网卡聚合及bond模式原理/" >linux网卡聚合及bond模式原理</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-02-08  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h1 id="linux网卡聚合及bond模式原理"><a href="#linux网卡聚合及bond模式原理" class="headerlink" title="linux网卡聚合及bond模式原理"></a>linux网卡聚合及bond模式原理</h1><h2 id="bonding的应用"><a href="#bonding的应用" class="headerlink" title="bonding的应用"></a>bonding的应用</h2><h3 id="网络负载均衡"><a href="#网络负载均衡" class="headerlink" title="网络负载均衡"></a>网络负载均衡</h3><p>用于解决一个ip地址，流量过大，服务器网络压力过大的问题。将多个网卡聚合在一起生成一个bond口，将ip配在这个bond口上，具体mac地址根据bond口的模式选择。</p>
<h3 id="网络冗余"><a href="#网络冗余" class="headerlink" title="网络冗余"></a>网络冗余</h3><p>通过冗余服务提供服务器的可靠性和安全性，多个网卡绑定到一个IP地址上，当一个网卡发生物理损坏时，另一块网卡也能提供正常服务。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>根据不同的模式有不同的原理，在介绍<a href="#%E6%A8%A1%E5%BC%8F">模式</a>时详细介绍。</p>
<p><img src="/2022/02/08/linux%E7%BD%91%E5%8D%A1%E8%81%9A%E5%90%88%E5%8F%8Abond%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86/bond.jpg"></p>
<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p>linux有7种网卡绑定模式：</p>
<table>
<thead>
<tr>
<th align="center">模式代号</th>
<th align="center">模式名称</th>
<th align="center">模式方式</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">balance-rr</td>
<td align="center">轮询模式</td>
<td align="center">按照设备顺序依次传输数据包，直到最后一个设备。提供负载均衡和容错能力</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">active-backup</td>
<td align="center">主备策略</td>
<td align="center">只有一个设备处于活动状态。一个宕机另一个马上由备变成主，mac地址外部可见。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">balance-xor</td>
<td align="center">异或策略</td>
<td align="center">该策略是根据mac地址异或运算的结果来选择传输设备</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">broadcase policy</td>
<td align="center">广播策略</td>
<td align="center">该策略将所有数据包传输给所有接口通过全部设备来传输所有数据，提供容错能力。（每个网卡上发一份）</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">802.3ad</td>
<td align="center">动态链路聚合</td>
<td align="center">该策略通过创建聚合组来共享相同的传输能力，需要交换机支持802.3ad</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">balance-tlb</td>
<td align="center">适配器传输负载均衡</td>
<td align="center">发送数据给每一个设备，由当前试用的设备处理收到的数据。（这个不是业务的问题吗？和广播策略的异同）</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">balance-alb</td>
<td align="center">适配器负载均衡</td>
<td align="center">该策略在IPV4情况下包含适配器传输负载均衡策略，由ARP协商完成接收的负载，通道联合驱动程序截获ARP在本地系统发送出的请求，用其中一个设备的硬件地址覆盖从属设备的原地址。</td>
</tr>
</tbody></table>
<h2 id="balance-rr"><a href="#balance-rr" class="headerlink" title="balance-rr"></a>balance-rr</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>负载均衡<ul>
<li>所有链路处于负载均衡状态，采用轮询的方式往每条链路发送报文，可以通过ping验证。</li>
</ul>
</li>
<li>容错问题<ul>
<li>增加了带宽，当链路错误后，会将流量切换到正常的链路上。（这个问题需要跟一下，为什么在rr模式下会丢包）</li>
</ul>
</li>
<li>性能问题<ul>
<li>连接包从不同的接口发出，中途经过不同的链路，在客户端处可能出现包乱序问题（也有可能在某种情况下，链路网络状态差导致丢包），在实际使用中避免接不同的交换机可以在一定程度上避免这个问题。</li>
</ul>
</li>
<li>交换机支持<ul>
<li>该模式下所有绑定的网卡的ip都被修改成同一个mac地址，此时交换机收到发往该mac地址的数据包，将不知道从对应的那个端口发该数据，交换机应该做端口绑定，将数据发往给逻辑端口，之后由逻辑端口转发数据。</li>
</ul>
</li>
<li>原理<ul>
<li>实际上就是将所有网卡的地址变为一个地址，然后由交换机将报文发送给bond口，然后由驱动层算法分别转发到不同的真实网卡</li>
</ul>
</li>
</ul>
<p><img src="/2022/02/08/linux%E7%BD%91%E5%8D%A1%E8%81%9A%E5%90%88%E5%8F%8Abond%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86/bond_rr.png"></p>
<h2 id="active-backup"><a href="#active-backup" class="headerlink" title="active-backup"></a>active-backup</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul>
<li>容错能力<ul>
<li>只有一个slave是激活状态，同时只有一个网卡能够工作，只有当当前网卡故障后其他网卡才会激活。发生failover时，切换的网卡会发出arp请求</li>
</ul>
</li>
<li>无负载均模式<ul>
<li>同时只有一个接口处于工作状态</li>
</ul>
</li>
<li>无需交换机支持<ul>
<li>mac地址采用的是bond0的mac地址，因此mac地址是唯一的（这个为什么会有只有一个mac地址，如果交换机多个端口都是这个mac地址没有问题吗？）</li>
<li>实际上mac地址都是一致的，但是只有一个网卡生效</li>
</ul>
</li>
</ul>
<p><img src="/2022/02/08/linux%E7%BD%91%E5%8D%A1%E8%81%9A%E5%90%88%E5%8F%8Abond%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86/bond_ac.png"></p>
<p><img src="/2022/02/08/linux%E7%BD%91%E5%8D%A1%E8%81%9A%E5%90%88%E5%8F%8Abond%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86/bond_ac_log.png"></p>
<h2 id="load-balancing-xor"><a href="#load-balancing-xor" class="headerlink" title="load balancing(xor)"></a>load balancing(xor)</h2><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul>
<li>负载均衡和容错能力<ul>
<li>基于指定的传输HASH策略传输数据包。缺省的负载均衡策略是：(源mac地址XOR目标mac地址)%slave数量，其他传输策略可以通过xmit_hash_policy选项指定。</li>
</ul>
</li>
<li>性能问题<ul>
<li>该模式将限定流量，以保证到达特定对端的流量总是从同一个接口上发出。既然目的地是通过MAC地址来决定的，因此该模式在“本地”网络配置下可以工作得很好。如果所有流量是通过单个路由器（比如 “网关”型网络配置，只有一个网关时，源和目标mac都固定了，那么这个算法算出的线路就一直是同一条，那么这种模式就没有多少意义了。）源mac是交换机的mac，目的mac是bond0上的mac。再交换机后不建议采用该模式</li>
</ul>
</li>
<li>交换机支持<ul>
<li>和balance-rr一样，需要交换机配置成“port channel”。该模式通过源和目标mac做hash因子来做xor算法来选路。</li>
</ul>
</li>
</ul>
<h2 id="fault-tolerance"><a href="#fault-tolerance" class="headerlink" title="fault-tolerance"></a>fault-tolerance</h2><p>这种模式的特点是一个报文会复制两份往bond下的两个接口分别发送出去，当有对端交换机失效，我们感觉不到任何downtime，但此法过于浪费资源；不过这种模式有很好的容错机制。此模式适用于金融行业，因为他们需要高可靠性的网络，不允许出现任何问题。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>这种模式适用于如下拓扑，两个接口分别接入两台交换机，并且属于不同的vlan，当一边的网络出现故障不会影响服务器另一边接入的网络正常工作。而且故障过程是0丢包。</p>
<h2 id="lacp-802-3ad"><a href="#lacp-802-3ad" class="headerlink" title="lacp(802.3ad)"></a>lacp(802.3ad)</h2><h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><p>802.3ad模式是IEEE标准，因此所有实现了802.3ad的对端都可以很好的互操作。802.3ad 协议包括聚合的自动配置，因此只需要很少的对交换机的手动配置（要指出的是，只有某些设备才能使用802.3ad）。802.3ad标准也要求帧按顺序（一定程度上）传递，因此通常单个连接不会看到包的乱序。802.3ad也有些缺点：标准要求所有设备在聚合操作时，要在同样的速率和双工模式，而且，和除了balance-rr模式外的其它bonding负载均衡模式一样，任何连接都不能使用多于一个接口的带宽。（保证了连接的顺序传递，但是所有接口的速率同步）</p>
<p>要求参与绑定的端口都运行802.3ad协议。该方式与band0很相似，但是又有区别。在IEEE802.3ad中，“链路聚合控制协议（LACP）”自动通知交换机应该聚合哪些端口，IEEE802.3ad聚合配置之后，链路聚合控制协议单元（LACPDU）就会在服务器和交换机之间进行交换，LACP会通知交换机在聚合中配置的适配器应作为交换机上的一个适配器来考虑，而不再有用户的干预。（按照协议应当如此，但是H3C5500-EI交换机上并未发现有单独启用802.3ad或LACP的命令，而聚合组中的静态聚合的所有端口均不启用LACP协议，所以如果按照band4的模式操作的话，建议在交换机上手工做动态端口聚合，且手工指定全局报文按照源MAC和目的MAC地址进行聚合负载分担。）根据IEEE802.3ad的规范，前往相同IP地址的数据包都会通过相同的适配器进行发送。因此当在802.3ad方式下操作时，信息包会始终按照标准（standard）的方式进行分发，而不会按照轮询（Round-Robin）方式进行分发。</p>
<ul>
<li>交换机配置<ul>
<li>interface AggregatePort 1 配置聚合口 interface GigabitEthernet 0&#x2F;23 port-group 1 mode active 接口下开启lacp 主动模式 interface GigabitEthernet 0&#x2F;24 port-group 1 mode active</li>
</ul>
</li>
<li>必要条件<ul>
<li>ethtool支持获取每个slave的速率和双工设定 </li>
<li>switch(交换机)支持IEEE 802.3ad Dynamic link aggregation </li>
<li>大多数switch(交换机)需要经过特定配置才能支持802.3ad模式</li>
</ul>
</li>
</ul>
<h2 id="balance-tlb"><a href="#balance-tlb" class="headerlink" title="balance-tlb"></a>balance-tlb</h2><p>balance-tlb模式通过对端均衡外出（outgoing）流量。既然它是根据MAC地址进行均衡，在“网关”型配置（如上文所述）下，该模式会通过单个设备来发送所有流量，然而，在“本地”型网络配置下，该模式以相对智能的方式（不是balance-xor或802.3ad模式里提及的XOR方式）来均衡多个本地网络对端，因此那些数字不幸的MAC地址（比如XOR得到同样值）不会聚集到同一个接口上。不像802.3ad，该模式的接口可以有不同的速率，而且不需要特别的交换机配置。不利的一面在于，该模式下所有进入的（incoming）流量会到达同一个接口；该模式要求slave接口的网络设备驱动有某种ethtool支持；而且ARP监控不可用。</p>
<h2 id="balance-alb"><a href="#balance-alb" class="headerlink" title="balance-alb"></a>balance-alb</h2><p>该模式包含了balance-tlb模式，同时加上针对IPV4流量的接收负载均衡(receive load balance， rlb)，而且不需要任何switch(交换机)的支持。接收负载均衡是通过ARP协商实现的。bonding驱动截获本机发送的ARP应答，并把源硬件地址改写为bond中某个slave的唯一硬件地址，从而使得不同的对端使用不同的硬件地址进行通信。所有端口都会收到对端的arp请求报文，回复arp回时，bond驱动模块会截获所发的arp回复报文，根据算法算到相应端口，这时会把arp回复报文的源mac，send源mac都改成相应端口mac。从抓包情况分析回复报文是第一个从端口1发，第二个从端口2发。以此类推。</p>
<p>当本机发送ARP请求时，bonding驱动把对端的IP信息从ARP包中复制并保存下来。当ARP应答从对端到达时，bonding驱动把它的硬件地址提取出来，并发起一个ARP应答给bond中的某个slave(这个算法和上面一样，比如算到1口，就给发送arp请求，1回复时mac用1的mac)。使用ARP协商进行负载均衡的一个问题是：每次广播 ARP请求时都会使用bond的硬件地址，因此对端学习到这个硬件地址后，接收流量将会全部流向当前的slave。这个问题通过给所有的对端发送更新（ARP应答）来解决，往所有端口发送应答，应答中包含他们独一无二的硬件地址，从而导致流量重新分布。当新的slave加入到bond中时，或者某个未激活的slave重新激活时，接收流量也要重新分布。接收的负载被顺序地分布（round robin）在bond中最高速的slave上。</p>

	
	</div>
  <a type="button" href="/2022/02/08/linux网卡聚合及bond模式原理/#more" class="btn btn-default more">Read More</a>
</div>

		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">

   
    
           <a type="button" class="btn btn-default disabled"><i class="fa fa-arrow-circle-o-left"></i>Prev</a>
        

        <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
 
       <a href="/page/2/" type="button" class="btn btn-default ">Next<i class="fa fa-arrow-circle-o-right"></i></a>     
        

  
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			
  <div id="site_search">
   <div class="form-group">
    <input type="text" id="local-search-input" name="q" results="0" placeholder="Search" class="st-search-input st-default-search-input form-control"/>
   </div>  
  <div id="local-search-result"></div>
  </div>


		
			
	<div class="widget">
		<h4>Categories</h4>
		<ul class="tag_box inline list-unstyled">
		
			<li><a href="/categories/computer/">computer<span>1</span></a></li>
		
			<li><a href="/categories/dpdk/">dpdk<span>1</span></a></li>
		
			<li><a href="/categories/os/">os<span>10</span></a></li>
		
		</ul>
	</div>

		
			
	<div class="widget">
		<h4>Tag Cloud</h4>
		<ul class="tag_box inline list-unstyled">		
		
			<li><a href="/tags/computer/">computer<span>1</span></a></li>
		
			<li><a href="/tags/network/">network<span>9</span></a></li>
		
			<li><a href="/tags/dpdk/">dpdk<span>1</span></a></li>
		
			<li><a href="/tags/memory/">memory<span>1</span></a></li>
		
			<li><a href="/tags/os/">os<span>1</span></a></li>
		
		 
		</ul>
	</div>


		
			
<div class="widget">
  <h4>Recent Posts</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2022/06/13/ip-range/" ><i class="fa fa-file-o"></i>ip_range</a>
      </li>
    
      <li>
        <a href="/2022/05/20/路由/" ><i class="fa fa-file-o"></i>路由</a>
      </li>
    
      <li>
        <a href="/2022/04/18/操作系统导论/" ><i class="fa fa-file-o"></i>操作系统导论</a>
      </li>
    
      <li>
        <a href="/2022/04/12/计算机是怎样跑起来的/" ><i class="fa fa-file-o"></i>计算机是怎样跑起来的</a>
      </li>
    
      <li>
        <a href="/2022/04/10/dpdk深入浅出/" ><i class="fa fa-file-o"></i>dpdk深入浅出</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>Links</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-github"></i><a href="https://github.com/wzpan/hexo-theme-freemind" title="Freemind's Github repository." target="_blank">Freemind</a></li>
	
		<li><i class="fa fa-github"></i><a href="https://github.com/kristopolous/BOOTSTRA.386" title="BOOTSTRA.386's Github repository." target="_blank">BOOTSTRA.386</a></li>
	
		<li><i class="fa fa-github"></i><a href="https://github.com/blackshow/hexo-theme-freemind.386" title="Freemind.386's Github repository." target="_blank">Freemind.386</a></li>
	
		<li><i class="fa fa-github"></i><a href="http://www.github.com/GiddyPoet" title="My Github account." target="_blank">My Github</a></li>
	
	</ul>
</div>


		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->
	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2022 GiddyPoet
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a>,<a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>,<a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a> and <a href="http://getbootstrap.com/" target="_blank">BOOTSTRA.386</a>. 
     <br> Theme by <a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind.386</a>.    
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



</body>
   </html>
