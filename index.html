<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>GiddyPoet</title>
  <meta name="author" content="GiddyPoet">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="GiddyPoet"/>

  
    <meta property="og:image" content=""/>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-70812759-1', 'auto');
  ga('send', 'pageview');
</script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?cb5448498d7169c668b07c2b255d62c1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


<meta name="generator" content="Hexo 6.0.0"></head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">GiddyPoet</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class=""></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class=""></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class=""></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class=""></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="page-header logo">
  <h1>GiddyPoet<span class="blink-fast">∎</span></h1>
</div>

<div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">


		<i class="fa fa-heart blink-slow"></i>

		Better to run than curse the road.

</div>    

		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/07/26/拔网线tcp连接会发生什么/" >拔网线tcp连接会发生什么</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-07-26  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h1 id="拔网线tcp连接会发生什么"><a href="#拔网线tcp连接会发生什么" class="headerlink" title="拔网线tcp连接会发生什么"></a>拔网线tcp连接会发生什么</h1><p>这个问题需要考虑三种情况：</p>
<ol>
<li>是否开启keepalived</li>
<li>是否正在收发数据</li>
<li>没有收发数据</li>
</ol>
<h2 id="是否开启tcp-keepalived"><a href="#是否开启tcp-keepalived" class="headerlink" title="是否开启tcp keepalived"></a>是否开启tcp keepalived</h2><p>可以通过<code>setsockopt</code>实现tcp keepalived。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsockopt(fd,SOL_SOCKET,SO_KEEPALIVE, &amp;on,<span class="keyword">sizeof</span>(on));</span><br></pre></td></tr></table></figure>

<p><code>tcp keepalived</code>的默认时间是<code>/proc/sys/net/ipv4/tcp_keepalive_time</code>设置的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@TAP ~]# cat /proc/sys/net/ipv4/tcp_keepalive_time </span><br><span class="line">7200</span><br></pre></td></tr></table></figure>

<blockquote>
<p>7200秒，直接是2个小时，简单来说如果连接没有任何连接相关的活动，则会启动保活机制，一段时间内没有收到报文。</p>
</blockquote>
<p>实际上检测机制就是通过发送keepalive包实现，那么发送间隔和检测次数分别是如下参数设置的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 发送间隔</span></span><br><span class="line">[root@TAP ~]# cat /proc/sys/net/ipv4/tcp_keepalive_intvl </span><br><span class="line">75</span><br><span class="line"><span class="meta">#</span><span class="bash"> 9次才认为连接失效</span></span><br><span class="line">[root@TAP ~]# cat /proc/sys/net/ipv4/tcp_keepalive_probes</span><br><span class="line">9</span><br></pre></td></tr></table></figure>

<p>如果两端的 TCP 连接一直没有数据交互，达到了触发 TCP 保活机制的条件，那么内核里的 TCP 协议栈就会发送探测报文。</p>
<ul>
<li>如果对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 TCP 保活时间会被重置，等待下一个 TCP 保活时间的到来。</li>
<li>如果对端主机崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，TCP 会报告该 TCP 连接已经死亡。</li>
</ul>
<blockquote>
<p>综上所述就是如果开启了tcp keepalived的话，最快需要7200+（75*9） &#x3D; 7875秒才能发现断网</p>
</blockquote>
<h2 id="不存在数据传输"><a href="#不存在数据传输" class="headerlink" title="不存在数据传输"></a>不存在数据传输</h2><p>如果客户端断网了，服务端是无法感知到的，在加上服务端没有开启 TCP keepalive，又没有数据交互的情况下，服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态，直到服务端重启进程。</p>
<p>如果是进程崩溃了，在linux下，服务端进程崩溃，操作系统会释放连接，实现4次挥手。</p>
<h2 id="有数据传输"><a href="#有数据传输" class="headerlink" title="有数据传输"></a>有数据传输</h2><p>这种情况下分2种情况讨论：</p>
<ol>
<li>客户端网络快速恢复</li>
<li>客户端网络没有恢复</li>
</ol>
<h3 id="客户端网络快速恢复"><a href="#客户端网络快速恢复" class="headerlink" title="客户端网络快速恢复"></a>客户端网络快速恢复</h3><p>此时服务端会重传报文，服务端重传或超时时间到达一定阈值后，客户端还是没有任何包回复，内核会将这个消息通给应用程序。</p>
<h3 id="客户端网络没有恢复"><a href="#客户端网络没有恢复" class="headerlink" title="客户端网络没有恢复"></a>客户端网络没有恢复</h3><p>这种情况，服务端超时重传报文的次数达到一定阈值后，内核就会判定出该 TCP 有问题，然后通过 Socket 接口告诉应用程序该 TCP 连接出问题了。</p>
<h3 id="如果客户端主机宕机"><a href="#如果客户端主机宕机" class="headerlink" title="如果客户端主机宕机"></a>如果客户端主机宕机</h3><p>服务端重传报文的过程中，刚好客户端主机重启完成，这时客户端的内核就会接收重传的报文，：</p>
<ul>
<li>如果客户端主机上没有进程监听该 TCP 报文的目标端口号，由于找不到目标端口，客户端内核就会回复 RST 报文，重置该 TCP 连接；</li>
<li>如果客户端主机上有进程监听该 TCP 报文的目标端口号，由于客户端主机重启后，之前的 TCP 连接的数据结构已经丢失了，客户端内核里协议栈会发现找不到该 TCP 连接的 socket 结构体，于是就会回复 RST 报文，重置该 TCP 连接。</li>
</ul>
<blockquote>
<p>简单来说，有数据传输的场景分为以下：客户端网络没恢复，服务端断链，客户端网络恢复，在超时和重传内，则正常建链，</p>
</blockquote>

	
	</div>
  <a type="button" href="/2022/07/26/拔网线tcp连接会发生什么/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/07/19/wireguard/" >wireguard</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-07-19  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h1 id="WireGuard"><a href="#WireGuard" class="headerlink" title="WireGuard"></a>WireGuard</h1><p><code>WireGuard</code>是由<code>Jason Donenfeld</code>等大佬用<code>C</code>语言编写的一个开源VPN协议，被视为下一代VPN，旨在解决现有VPN技术如<code>IPSec</code>、<code>Openvpn</code>等技术的痛点。<br><code>WireGuard</code>是一个利用现有社会最先进的加密技术而产生的非常简单和快捷的VPN工具。它的目标是比 <code>IPsec</code>更快，更简单，更精简，更易用，同时避免大规模配置<code>IPsec</code>的麻烦事。同时<code>WireGuard</code>也打算比<code>OpenVPN</code>更高效。</p>
<p><img src="/2022/07/19/wireguard/wireguard_performance.jpg"></p>
<h2 id="配置使用"><a href="#配置使用" class="headerlink" title="配置使用"></a>配置使用</h2><h3 id="WireGuard相关定义"><a href="#WireGuard相关定义" class="headerlink" title="WireGuard相关定义"></a>WireGuard相关定义</h3><ul>
<li>Peer：节点，对于<code>WireGuard</code>来说所有节点之间都是对等的，每一个启动<code>WireGuard</code>实例的节点都是一个peer</li>
<li>Bounce Server(中继服务器)：类似内网穿透的原理，当设备在NAT内，需要进行通信，则可以通过中继服务器实现两个节点之间的通信，中继服务作为一个Peer，充当消息的中介。</li>
<li>私钥：<code>WireGuard</code>所用的私钥，通过<code>wg genkey</code>生成</li>
<li>公钥：<code>WireGuard</code>所用的公钥，通过<code>wg genkey privatekey</code>生成公钥，公钥在与邻居节点建立连接关系的时候使用</li>
<li>IP漫游：<code>WireGuard</code>由于是无连接的，因此如果双方地址发生变动，通过协议可以记录其新地址</li>
</ul>
<h3 id="WireGuard工作模式"><a href="#WireGuard工作模式" class="headerlink" title="WireGuard工作模式"></a>WireGuard工作模式</h3><ul>
<li>Direct Node-to-Node：点对点模式，节点在同一局域网或者都在公网</li>
<li>Node behind local NAT to Public node：一个在内网通过NAT访问公网节点，配置PerisistentKeepalived，实现连接保持，维护NAT设备上的连接信息</li>
<li>Node behind local NAT to node behind remote NAT (via relay)：两个节点都在NAT内，通过中继服务器实现内网穿透，中继服务器用于转发连接</li>
<li>Node behind local NAT to node behind remote NAT (via UDP NAT hole-punching)：UDP nat打洞模式，udp打洞</li>
</ul>
<p><img src="/2022/07/19/wireguard/nat.jpg"></p>
<h3 id="WireGuard配置"><a href="#WireGuard配置" class="headerlink" title="WireGuard配置"></a>WireGuard配置</h3><blockquote>
<p>本测试场景基于vmware虚拟机测试，虚拟出两台设备，IP分别为192.168.74.150和192.168.74.151。采用的是Ubuntu22.04。</p>
</blockquote>
<p>本地节点配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- node1 --&gt;</span><br><span class="line">[Interface]</span><br><span class="line">Address = 172.16.1.11/24</span><br><span class="line">ListenPort = 8001</span><br><span class="line">PrivateKey = 6JNM0s6crFOAleXhL+rt6kJTyyFrXWrVql97ZnvTmUQ=</span><br><span class="line"></span><br><span class="line">[Peer]</span><br><span class="line">PublicKey = 94jlm8+3rr5KtFMJqHubgDgRa87/Fb0Xc9ql2LUp2RA=</span><br><span class="line">AllowedIPs = 0.0.0.0/0,::/0</span><br><span class="line">Endpoint = 192.168.74.151:8001</span><br><span class="line">PersistentKeepalive = 25</span><br></pre></td></tr></table></figure>

<p>对端节点配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- node2 --&gt;</span><br><span class="line">[Interface]</span><br><span class="line">Address = 172.16.1.12/24</span><br><span class="line">ListenPort = 8002</span><br><span class="line">PrivateKey = qDRJf3UodsOrBdt78Hce9eSYLpynCA2CQGyzXY5BS2w=</span><br><span class="line"></span><br><span class="line">[Peer]</span><br><span class="line">PublicKey = rtdDoG02qkydY6sOBlfC9+IGqZXxhunLRVLPPNZKKAQ=</span><br><span class="line">AllowedIPs = 0.0.0.0/0,::/0</span><br><span class="line">Endpoint = 192.168.74.150:8001</span><br><span class="line">PersistentKeepalive = 25</span><br></pre></td></tr></table></figure>

<h4 id="配置文件解析"><a href="#配置文件解析" class="headerlink" title="配置文件解析"></a>配置文件解析</h4><p><code>WireGuard</code>使用INI语法作为其配置文件格式。默认路径是<code>/etc/wireguard/wg0.conf</code>.</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Interface]</span></span><br><span class="line"><span class="comment"># Name = phone.example-vpn.dev</span></span><br><span class="line"><span class="attr">Address</span> = <span class="number">192.0</span>.<span class="number">2.5</span>/<span class="number">32</span></span><br><span class="line"><span class="attr">PrivateKey</span> = &lt;private key for phone.example-vpn.dev&gt;</span><br><span class="line"></span><br><span class="line"><span class="section">[Peer]</span></span><br><span class="line"><span class="comment"># Name = home-server.example-vpn.dev</span></span><br><span class="line"><span class="attr">Endpoint</span> = home-server.example-vpn.dev:<span class="number">51820</span></span><br><span class="line"><span class="attr">PublicKey</span> = &lt;public key for home-server.example-vpn.dev&gt;</span><br><span class="line"><span class="attr">AllowedIPs</span> = <span class="number">192.0</span>.<span class="number">2.3</span>/<span class="number">32</span></span><br><span class="line"><span class="attr">PersistentKeepalive</span> = <span class="number">25</span></span><br></pre></td></tr></table></figure>
<h5 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h5><ul>
<li>Address：定义本地节点应该对哪个地址范围进行路由。如果是常规的客户端，则将其设置为节点本身的单个 IP（使用 CIDR 指定，例如 192.0.2.3&#x2F;32）；如果是中继服务器，则将其设置为可路由的子网范围。<ul>
<li>常规客户端，只路由自身的流量</li>
<li>中继服务器，可以将流量转发到其他对等节点，路由网段的流量</li>
</ul>
</li>
<li>ListenPort：如果是中继服务时，需要通过该参数指定端口来监听传入VPN连接，默认端口号是51820</li>
<li>PrivateKey：本地节点私钥，通过<code>wg genkey</code>生成</li>
<li>DNS：处理vpn的DNS请求</li>
<li>Table：子网使用的路由表<ul>
<li>off：默认不创建</li>
<li>auto，将路由添加到系统的默认table中，并启用对默认路由的特殊处理。</li>
</ul>
</li>
<li>MTU：虚拟网卡的MTU设置</li>
<li>PreUp：启动vpn接口之前运行的命令</li>
<li>PostUp：启动vpn接口之后运行的命令</li>
<li>PreDown：停止接口前运行的命令</li>
<li>PostDown：停止接口后运行的命令</li>
</ul>
<h5 id="Peer"><a href="#Peer" class="headerlink" title="Peer"></a>Peer</h5><ul>
<li>EndPoint：指定对端节点的公网地址</li>
<li>AllowedIPs：允许该对等节点（peer）发送过来的 VPN 流量中的源地址范围。同时这个字段也会作为本机路由表中 wg0 绑定的 IP 地址范围。如果对等节点（peer）是常规的客户端，则将其设置为节点本身的单个 IP；如果对等节点（peer）是中继服务器，则将其设置为可路由的子网范围。可以使用 , 来指定多个 IP 或子网范围。</li>
<li>PublicKey：对等节点（peer）的公钥，所有节点（包括中继服务器）都必须设置。可与其他对等节点（peer）共用同一个公钥。</li>
<li>PersistentKeepalive：如果连接是从一个位于 NAT 后面的对等节点（peer）到一个公网可达的对等节点（peer），那么 NAT 后面的对等节点（peer）必须定期发送一个出站 ping 包来检查连通性，如果 IP 有变化，就会自动更新Endpoint。<ul>
<li>本地节点与对等节点（peer）可直连：该字段不需要指定，因为不需要连接检查。</li>
<li>对等节点（peer）位于 NAT 后面：该字段不需要指定，因为维持连接是客户端（连接的发起方）的责任。</li>
<li>本地节点位于 NAT 后面，对等节点（peer）公网可达：需要指定该字段 PersistentKeepalive &#x3D; 25，表示每隔 25 秒发送一次 ping 来检查连接。</li>
</ul>
</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>其实<code>Wireguard</code>的原理有点类似<code>Openvpn</code>的<code>tun</code>模式，通过构建虚拟网卡，配置地址以及路由信息，实现导流。</p>
<blockquote>
<p>实际上wireguard只负责在节点之间传输加密后的数据，当节点之间的数据被解密后，会写到虚拟网卡上，会根据操作系统的路由进行转发。</p>
</blockquote>
<h3 id="中继服务器的原理"><a href="#中继服务器的原理" class="headerlink" title="中继服务器的原理"></a>中继服务器的原理</h3><p>简单介绍一下中继服务器的原理：<strong>实际上就是将从一个peer收到的流量直接转发到正确的peer上，具体怎么转发wireguard并不关心，中继服务器只需要维护一个映射关系，然后将ip包后转发到正确的peer上即可</strong></p>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><blockquote>
<p>later~</p>
</blockquote>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>其实这些P2P通信都无法规避一个问题：NAT问题，如果不想利用中继服务器，必须要解决NAT问题，业内常见的方案是UDP打洞的方式。</p>
<blockquote>
<p>基础NAT不在讨论范围内，只讨论NAPT</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">本地nat方式</th>
<th align="center">对端nat方式</th>
<th align="center">能否打洞</th>
<th align="center">打洞方式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">全锥型</td>
<td align="center">全锥型</td>
<td align="center">能</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">全锥型</td>
<td align="center">受限制锥型</td>
<td align="center">能</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">全锥型</td>
<td align="center">端口受限制锥型</td>
<td align="center">能</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">全锥型</td>
<td align="center">对称型</td>
<td align="center">能</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">受限锥型</td>
<td align="center">受限锥型</td>
<td align="center">能</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">受限锥型</td>
<td align="center">端口受限锥型</td>
<td align="center">能</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">受限锥型</td>
<td align="center">对称型</td>
<td align="center">能</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">端口受限锥型</td>
<td align="center">端口受限锥型</td>
<td align="center">能</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">端口受限锥型</td>
<td align="center">对称型</td>
<td align="center">否</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">对称型</td>
<td align="center">对称型</td>
<td align="center">否</td>
<td align="center"></td>
</tr>
</tbody></table>

	
	</div>
  <a type="button" href="/2022/07/19/wireguard/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/07/08/raw-socket/" >raw_socket</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-07-08  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h1 id="RAW-SOCKET"><a href="#RAW-SOCKET" class="headerlink" title="RAW_SOCKET"></a>RAW_SOCKET</h1><p>我们常用的套接字类型主要就是：</p>
<ul>
<li>TCP</li>
<li>UDP<br>原始套接字区别于上述的套接字，提供了普通TCP和UDP套接字不具备的3个能力：</li>
<li>读写ICMPv4、IGMPv4和IGMPv6等分组</li>
<li>有了原始套接字，进程可以读取内核不处理的IP type类型</li>
<li>有了原始套接字，进程可以使用<code>IP_HDRINCL</code>套接字选项构造TCP或UDP分组</li>
</ul>
<h2 id="原始套接字创建"><a href="#原始套接字创建" class="headerlink" title="原始套接字创建"></a>原始套接字创建</h2><p>原始套接字协议类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// netinet/in.h</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    IPPROTO_IP = <span class="number">0</span>,	   <span class="comment">/* Dummy protocol for TCP.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_IP		IPPROTO_IP</span></span><br><span class="line">    IPPROTO_ICMP = <span class="number">1</span>,	   <span class="comment">/* Internet Control Message Protocol.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_ICMP		IPPROTO_ICMP</span></span><br><span class="line">    IPPROTO_IGMP = <span class="number">2</span>,	   <span class="comment">/* Internet Group Management Protocol. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_IGMP		IPPROTO_IGMP</span></span><br><span class="line">    IPPROTO_IPIP = <span class="number">4</span>,	   <span class="comment">/* IPIP tunnels (older KA9Q tunnels use 94).  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_IPIP		IPPROTO_IPIP</span></span><br><span class="line">    IPPROTO_TCP = <span class="number">6</span>,	   <span class="comment">/* Transmission Control Protocol.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_TCP		IPPROTO_TCP</span></span><br><span class="line">    IPPROTO_EGP = <span class="number">8</span>,	   <span class="comment">/* Exterior Gateway Protocol.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_EGP		IPPROTO_EGP</span></span><br><span class="line">    IPPROTO_PUP = <span class="number">12</span>,	   <span class="comment">/* PUP protocol.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_PUP		IPPROTO_PUP</span></span><br><span class="line">    IPPROTO_UDP = <span class="number">17</span>,	   <span class="comment">/* User Datagram Protocol.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_UDP		IPPROTO_UDP</span></span><br><span class="line">    IPPROTO_IDP = <span class="number">22</span>,	   <span class="comment">/* XNS IDP protocol.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_IDP		IPPROTO_IDP</span></span><br><span class="line">    IPPROTO_TP = <span class="number">29</span>,	   <span class="comment">/* SO Transport Protocol Class 4.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_TP		IPPROTO_TP</span></span><br><span class="line">    IPPROTO_DCCP = <span class="number">33</span>,	   <span class="comment">/* Datagram Congestion Control Protocol.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_DCCP		IPPROTO_DCCP</span></span><br><span class="line">    IPPROTO_IPV6 = <span class="number">41</span>,     <span class="comment">/* IPv6 header.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_IPV6		IPPROTO_IPV6</span></span><br><span class="line">    IPPROTO_RSVP = <span class="number">46</span>,	   <span class="comment">/* Reservation Protocol.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_RSVP		IPPROTO_RSVP</span></span><br><span class="line">    IPPROTO_GRE = <span class="number">47</span>,	   <span class="comment">/* General Routing Encapsulation.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_GRE		IPPROTO_GRE</span></span><br><span class="line">    IPPROTO_ESP = <span class="number">50</span>,      <span class="comment">/* encapsulating security payload.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_ESP		IPPROTO_ESP</span></span><br><span class="line">    IPPROTO_AH = <span class="number">51</span>,       <span class="comment">/* authentication header.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_AH		IPPROTO_AH</span></span><br><span class="line">    IPPROTO_MTP = <span class="number">92</span>,	   <span class="comment">/* Multicast Transport Protocol.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_MTP		IPPROTO_MTP</span></span><br><span class="line">    IPPROTO_BEETPH = <span class="number">94</span>,   <span class="comment">/* IP option pseudo header for BEET.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_BEETPH		IPPROTO_BEETPH</span></span><br><span class="line">    IPPROTO_ENCAP = <span class="number">98</span>,	   <span class="comment">/* Encapsulation Header.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_ENCAP		IPPROTO_ENCAP</span></span><br><span class="line">    IPPROTO_PIM = <span class="number">103</span>,	   <span class="comment">/* Protocol Independent Multicast.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_PIM		IPPROTO_PIM</span></span><br><span class="line">    IPPROTO_COMP = <span class="number">108</span>,	   <span class="comment">/* Compression Header Protocol.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_COMP		IPPROTO_COMP</span></span><br><span class="line">    IPPROTO_SCTP = <span class="number">132</span>,	   <span class="comment">/* Stream Control Transmission Protocol.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_SCTP		IPPROTO_SCTP</span></span><br><span class="line">    IPPROTO_UDPLITE = <span class="number">136</span>, <span class="comment">/* UDP-Lite protocol.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_UDPLITE		IPPROTO_UDPLITE</span></span><br><span class="line">    IPPROTO_MPLS = <span class="number">137</span>,    <span class="comment">/* MPLS in IP.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_MPLS           IPPROTO_MPLS</span></span><br><span class="line">    IPPROTO_RAW = <span class="number">255</span>,	   <span class="comment">/* Raw IP packets.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPPROTO_RAW		IPPROTO_RAW</span></span><br><span class="line">    IPPROTO_MAX</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际上头文件包含了该协议类型，但是内核协议栈不一定支持该协议类型</p>
</blockquote>
<p>创建<code>RAW SOCKET</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// protocol 根据协议指定</span></span><br><span class="line">    fd = socket(AF_INET, SOCK_RAW, protocol);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> on = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果设置了IP_HDRINCL，则由程序构造IP包头，否则内核根据路由决定源IP是</span></span><br><span class="line">    <span class="keyword">if</span>(setsockopt(fd, IPPROTO_IP, IP_HDRINCL, &amp;on, <span class="keyword">sizeof</span>(on)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// error handler </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在不设置IP_HDRINCL时，根据bind选择源IP，否则失效</span></span><br><span class="line">    <span class="comment">// struct sockaddr_in addr;</span></span><br><span class="line">    <span class="comment">// memset(&amp;addr, 0, sizeof(addr));</span></span><br><span class="line">    <span class="comment">// addr.sin_family = AF_INET;</span></span><br><span class="line">    <span class="comment">// addr.sin_port = htons(80);</span></span><br><span class="line">    <span class="comment">// addr.sin_addr.s_addr = inet_addr(&quot;1.1.1.1&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// bind(fd, (struct sockaddr *) &amp;addr, sizeof(addr));</span></span><br><span class="line">    <span class="comment">// connect(fd, (struct sockaddr *)&amp;addr, sizeof(addr));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>bind实际上就是绑定源端口，在IP_HDRINCL设置的情况下，应该使用iphdr设置源地址，由于RAW_SOCKET不存在端口的概念，因此设置端口本身是无效的。<br>connect用于设置外部地址，同样目的端口无效，调用之后可以用write或者send调用，指定目的地址，如果没有调用connect也可以直接使用sendto指定目的地址。</p>
</blockquote>
<h2 id="原始套接字输出"><a href="#原始套接字输出" class="headerlink" title="原始套接字输出"></a>原始套接字输出</h2><p>输出调用：</p>
<ul>
<li>sendto, sendmsg: 指定目的IP地址完成</li>
<li>write，writev，send：通过connect之后可以发送</li>
</ul>
<p>是否开启IP_HDRINCL：</p>
<ul>
<li>未开启：内核填充IP包头</li>
<li>开启：输出函数缓冲区必须包含IP首部</li>
</ul>
<blockquote>
<p>对于自己构造的IP包，可以将标识字段置0，让内核控制该选项，即便是自定义IP头，首部校验和也是有内核计算存储，同时ipv4选项字段是可选字段。</p>
</blockquote>
<p><img src="/2022/07/08/raw-socket/iphdr.jpg"></p>

	
	</div>
  <a type="button" href="/2022/07/08/raw-socket/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/06/24/ebpf/" >ebpf</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-06-24  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h1 id="ebpf"><a href="#ebpf" class="headerlink" title="ebpf"></a>ebpf</h1><h2 id="ebpf的发展历史"><a href="#ebpf的发展历史" class="headerlink" title="ebpf的发展历史"></a>ebpf的发展历史</h2>
	
	</div>
  <a type="button" href="/2022/06/24/ebpf/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/06/24/xdp/" >xdp</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-06-24  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		
	
	</div>
  <a type="button" href="/2022/06/24/xdp/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/06/13/ip-range/" >ip_range</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-06-13  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h1 id="ip地址范围判断问题"><a href="#ip地址范围判断问题" class="headerlink" title="ip地址范围判断问题"></a>ip地址范围判断问题</h1><p>在实现场景中，时长遇到需要判断ip地址是否在范围内，或者ip地址是否在这个网段内，因此将简述ip地址判断问题，目前支持以下场景。</p>
<ul>
<li>ip1-ip2</li>
<li>ip&#x2F;CIDR (ip&#x2F;24)</li>
<li>ip&#x2F;netmask (ip&#x2F;255.255.255.0)</li>
</ul>
<h2 id="ip地址判断"><a href="#ip地址判断" class="headerlink" title="ip地址判断"></a>ip地址判断</h2><h3 id="ip地址格式"><a href="#ip地址格式" class="headerlink" title="ip地址格式"></a>ip地址格式</h3><p>常用的地址格式类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">short</span>    sa_family;    <span class="comment">// address family, AF_xxx</span></span><br><span class="line">   <span class="keyword">char</span>              sa_data[<span class="number">14</span>];  <span class="comment">// 14 bytes of protocol address</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">short</span>            sin_family;   <span class="comment">// e.g. AF_INET, AF_INET6</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>   sin_port;     <span class="comment">// e.g. htons(3490)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>   <span class="title">sin_addr</span>;</span>     <span class="comment">// see struct in_addr, below</span></span><br><span class="line">    <span class="keyword">char</span>             sin_zero[<span class="number">8</span>];  <span class="comment">// zero this if you want to</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line">    <span class="keyword">u_int16_t</span>       sin6_family;   <span class="comment">// address family, AF_INET6</span></span><br><span class="line">    <span class="keyword">u_int16_t</span>       sin6_port;     <span class="comment">// port number, Network Byte Order</span></span><br><span class="line">    <span class="keyword">u_int32_t</span>       sin6_flowinfo; <span class="comment">// IPv6 flow information</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>     <span class="comment">// IPv6 address</span></span><br><span class="line">    <span class="keyword">u_int32_t</span>       sin6_scope_id; <span class="comment">// Scope ID</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>  ss_family;     <span class="comment">// address family</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// all this is padding, implementation specific, ignore it:</span></span><br><span class="line">    <span class="keyword">char</span>      __ss_pad1[_SS_PAD1SIZE];</span><br><span class="line">    <span class="keyword">int64_t</span>   __ss_align;</span><br><span class="line">    <span class="keyword">char</span>      __ss_pad2[_SS_PAD2SIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>struct sockaddr</code> 通常不会自己创建，该结构体，一般都是通过<code>struct sockaddr_in</code>和<code>struct sockaddr_in6</code>进行转换，由于历史因素，因此套接字api都只支持<code>struct sockaddr</code>，通过family字段进行判断，同时支持ipv4和ipv6，如果一个ip地址是ipv4,它只会读取其前4个字节，如果是ipv6，则会读取完整的16个字节.s</li>
<li><code>struct sockaddr_in</code> ipv4地址格式</li>
<li><code>struct sockaddr_in6</code> ipv6地址格式</li>
<li><code>struct sockaddr_storage</code> 当你不知道地址类型具体是什么的时候可以使用该结构体，该结构体即支持ipv4也支持ipv6，该地址类型被设计的足够大可以支持<code>struct sockaddr_un</code></li>
</ul>
<blockquote>
<p>对于unix socket需要通过offsetof实现绑定，addrlen &#x3D; offsetof(struct sockaddr_un, sun_path) + strlen(un.sun_path); 需要制定具体的长度，上述地址格式一般都是历史遗留问题。</p>
</blockquote>
<h3 id="地址格式转换"><a href="#地址格式转换" class="headerlink" title="地址格式转换"></a>地址格式转换</h3><blockquote>
<p>从文件中读取ip地址，进行判断，通常这种配置都是通过点分形式通知，因此需要将ipstr转换成地址</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IPSTORAGE</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> is_ipv6;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">in_addr_t</span> ipv4;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">ipv6</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;IPSTORAGE;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISIPV6(str) (strchr(str,<span class="meta-string">&#x27;:&#x27;</span>)?true:false)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_legal_ip_addr</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[INET6_ADDRSTRLEN];</span><br><span class="line">    <span class="keyword">if</span>(ISIPV6(str)) &#123;</span><br><span class="line">        <span class="keyword">return</span> inet_pton(AF_INET6, str, buf) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> inet_pton(AF_INET, str, buf) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IPSTORAGE <span class="title">str2ipstorage</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    IPSTORAGE is;</span><br><span class="line">    <span class="keyword">if</span>(ISIPV6(str)) &#123;</span><br><span class="line">        is.is_ipv6 = <span class="literal">true</span>; </span><br><span class="line">        inet_pton(AF_INET6, str, &amp;is.ipv6);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        is.is_ipv6 = <span class="literal">false</span>;</span><br><span class="line">        inet_pton(AF_INET, str, &amp;is.ipv4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *f = fopen(<span class="string">&quot;./test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf, <span class="keyword">sizeof</span>(buf), f)!= <span class="literal">NULL</span>) &#123;</span><br><span class="line">        buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!is_legal_ip_addr(buf)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;illegal ip addr %s.\n&quot;</span>, buf);</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">continue</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ip addr %s\n&quot;</span>,buf);</span><br><span class="line"></span><br><span class="line">        IPSTORAGE is = str2ipstorage(buf);</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码就是常见的字符串转ip地址的常用场景，主要说明一下几点：</p>
<ol>
<li>为什么要自己定义IPSTORAGE，实际上就是便于处理ipv4和ipv6的兼容性，<code>struct sockaddr_storage</code>也能实现该功能，但是还是要借助<code>struct sockaddr_in</code>和<code>struct sockaddr_in6</code>，用union处理<code>in_addr_t</code>和<code>struct in6_addr</code>处理起来较为方便。</li>
<li>利用inet_pton检查ip格式的合法性，这个比较常见。</li>
</ol>
<h3 id="ip地址范围判定"><a href="#ip地址范围判定" class="headerlink" title="ip地址范围判定"></a>ip地址范围判定</h3><h4 id="ip1-ip2"><a href="#ip1-ip2" class="headerlink" title="ip1-ip2"></a>ip1-ip2</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ipstorage_lt</span><span class="params">(IPSTORAGE *is1, IPSTORAGE *is2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(is1-&gt;is_ipv6) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;is1-&gt;ipv6, &amp;is2-&gt;ipv6, <span class="keyword">sizeof</span>(struct in6_addr)) &lt; <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (is-&gt;ipv4) &lt; (is-&gt;ipv4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ipstorage_gt</span><span class="params">(IPSTORAGE *is1, IPSTORAGE *is2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !ipstorage_lt(is1,is2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ipstorage_between</span><span class="params">(IPSTORAGE *dst, IPSTORAGE *left, IPSTORAGE *right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dst-&gt;is_ipv6 != left-&gt;is_ipv6) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ipstorage_gt(dst, right) || ipstorage_lt(dst, left)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实ipv4地址基于网络字节序或者主机字节序做比较都可以，只是由现成将str转换成网络字节序的函数，直接用网络字节序比较方便<br>ipv6的地址比较直接比较内存大小就可以，ipv6是16个uint8做比较。</p>
</blockquote>
<h4 id="ip-x2F-CIDR或ip-x2F-netmask"><a href="#ip-x2F-CIDR或ip-x2F-netmask" class="headerlink" title="ip&#x2F;CIDR或ip&#x2F;netmask"></a>ip&#x2F;CIDR或ip&#x2F;netmask</h4><p>先做判断，只要判断”&#x2F;“后是不是地址，就可以区分CIDR或netmask。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_ipv4</span><span class="params">(<span class="keyword">char</span> *ip)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="keyword">return</span> inet_pton(AF_INET, ip, buf)? <span class="literal">true</span>: <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 255.255.255.0 = 1111 1111 1111 1111 1111 1111 0000 0000 位运算</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mask2prefix</span><span class="params">(struct in_addr addr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">uint32_t</span> saddr = ntohl(mask.s_addr);</span><br><span class="line">    <span class="keyword">for</span>(count = <span class="number">0</span>; saddr &gt; <span class="number">0</span>; count++) &#123;</span><br><span class="line">        saddr = saddr &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct in_addr <span class="title">prefix2mask</span><span class="params">(<span class="keyword">int</span> prefix)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">addr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(prefix) &#123;</span><br><span class="line">        addr.s_addr = htonl(~(<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - preix) <span class="number">-1</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        addr.s_addr = htonl(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_ipv6_host_in_route</span><span class="params">(IPSTORAGE *is1, <span class="keyword">int</span> prefix, IPSTORAGE *is2)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> *<span class="title">route</span> =</span> &amp;is1-&gt;ipv6;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> *<span class="title">host</span> =</span> &amp;is2-&gt;ipv6;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prefix是8的整数的每个uint8_t 做对比，剩下的不足一个字节的 前bit个位做对比</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> bits = prefix;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; bits &gt;= <span class="number">8</span>; i++, bits -=<span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(route-&gt;s6_addr[i] != host-&gt;s6_addr[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bits == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> mask = <span class="number">0xff</span> &lt;&lt;( <span class="number">8</span> - bits);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((route-&gt;s6_addr[i]&amp;mask) == (host-&gt;s6_addr[i] &amp; mask)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ipstorage_inside</span><span class="params">(IPSTORAGE *is1, <span class="keyword">int</span> prefix, IPSTORAGE *is2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(is1-&gt;is_ipv6 != is2-&gt;is_ipv6) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(is1-&gt;is_ipv6) &#123;</span><br><span class="line">        <span class="keyword">return</span> is_ipv6_host_in_route(is1, prefix, is2);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        struct in_addr in = prefix2mask(prefix);</span><br><span class="line">        <span class="keyword">uint32_t</span> mask = ntohl(in_addr.s_addr);</span><br><span class="line">        <span class="keyword">if</span>((is1-&gt;ipv4 &amp; mask) == (is2-&gt;ipv4 &amp; mask)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ptr = <span class="built_in">strchr</span>(str, <span class="string">&#x27;/&#x27;</span>)) &#123;</span><br><span class="line">    *ptr++ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> prefix;</span><br><span class="line">    <span class="keyword">if</span>((is_ipv4(ptr))) &#123;</span><br><span class="line">        <span class="comment">// netmask</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">maskaddr</span>;</span></span><br><span class="line">        maskaddr.s_addr = inet_addr(ptr);</span><br><span class="line">        prefix = mask2prefix(maskaddr);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// CIDR</span></span><br><span class="line">        prefix = atoi(ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IPSTORAGE is1 = str2ipstorage(buf);</span><br><span class="line">    IPSTORAGE is2 = str2ipstorage(dst_ip);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ipstrorage_inside(&amp;is1, prefix, &amp;is2)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ip in range.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际上上述的操作都是利用了两个特性</p>
<ol>
<li>ipv4地址实际上是一个uint32_t</li>
<li>ipv6地址实际上是一个uint8_t[16], 这样就不区分主机字节序或网络字节序了</li>
</ol>
</blockquote>
<ol>
<li>先获取到子网掩码</li>
<li>如果是ipv4的话就直接通过主机号做判断，地址1 &amp; 子网掩码 &#x3D;&#x3D; 地址2 &amp; 子网掩码</li>
<li>如果是ipv6的话就每一个字节进行判断，不足一个字节，取高bits，(is1-&gt;s6_addr[i] &amp; bits) &#x3D;&#x3D; (is2-&gt;s6_addr[i] &amp; bits)</li>
</ol>
<h5 id="ipv6不区分网络字节序相关验证"><a href="#ipv6不区分网络字节序相关验证" class="headerlink" title="ipv6不区分网络字节序相关验证"></a>ipv6不区分网络字节序相关验证</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str6 = <span class="string">&quot;fec1::02&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> prefix = <span class="number">64</span>; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">ipv6</span>;</span></span><br><span class="line"></span><br><span class="line">    inet_pton(AF_INET6, str6, &amp;ipv6); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; <span class="number">16</span> ;i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%x &quot;</span>, ipv6.s6_addr[i]);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;                                         </span><br></pre></td></tr></table></figure>


<h4 id="对于unix-socket的相关操作"><a href="#对于unix-socket的相关操作" class="headerlink" title="对于unix socket的相关操作"></a>对于unix socket的相关操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATH <span class="meta-string">&quot;/tmp/GiddyPoet&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">un</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">ss</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">socklen_t</span> len;</span><br><span class="line"></span><br><span class="line">    unlink(PATH);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;un ,<span class="number">0</span> , <span class="keyword">sizeof</span>(un));</span><br><span class="line">    un.sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strcpy</span>(un.sun_path, PATH);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> addrlen = offsetof(struct sockaddr_un, sun_path) + <span class="built_in">strlen</span>(PATH);</span><br><span class="line"></span><br><span class="line">    bind(fd, (struct sockaddr *)&amp;un, addrlen);</span><br><span class="line"></span><br><span class="line">    listen(fd, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> client_fd = accept(fd, (struct sockaddr *)&amp;ss, &amp;len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ss.ss_family == AF_UNIX) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;AF_UNIX.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(st, m) ((size_t) \</span></span><br><span class="line"><span class="meta">    ((char *)&amp;((st *)0)-&gt;m - (char *)0))</span></span><br></pre></td></tr></table></figure>

<p>简单介绍下<code>offsetof</code>，通过将起始地址为0的结构体中的m成员获取，m在结构体中的偏移量，然后转换成<code>char *</code>计算出具体偏移的字节数, ((st *)(0))指的NULL是类型的指针st *。 &amp;((st *)(0))-&gt;m指的是这个对象中成员m的地址。由于这个对象的起始地址是0 (NULL)，所以成员 m 的地址就是偏移量。</p>
<h4 id="contain-of"><a href="#contain-of" class="headerlink" title="contain_of"></a>contain_of</h4><p>contain_of是通过结构体内成员的地址返回结构体本身的地址，在内核代码里有大量使用，典型的就是list.h。</p>
<p>既然介绍了offset，顺便介绍下contain_of, <code>const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr)</code>获取同类型的指针，<code>offsetof(type,member)</code>计算出结构体成员的相对偏移量，<code>( (char *)__mptr - offsetof(type,member) )</code>获取机构体本身的地址，<code>(type *)( (char *)__mptr - offsetof(type,member) )</code>转换成结构体类型返回。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container_of(ptr, type, member) (&#123;			\</span></span><br><span class="line"><span class="meta">	const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);	\</span></span><br><span class="line"><span class="meta">	(type *)( (char *)__mptr - offsetof(type,member) );&#125;)</span></span><br></pre></td></tr></table></figure>

	
	</div>
  <a type="button" href="/2022/06/13/ip-range/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/04/18/操作系统导论/" >操作系统导论</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-04-18  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h1 id="第一章-关于本书的对话"><a href="#第一章-关于本书的对话" class="headerlink" title="第一章 关于本书的对话"></a>第一章 关于本书的对话</h1><p>Operating Systems: Three Easy Pieces：</p>
<ul>
<li>虚拟化(virtualization)</li>
<li>并发(concurrency)</li>
<li>持久性(persistence)</li>
</ul>
<h1 id="第二章-操作系统介绍"><a href="#第二章-操作系统介绍" class="headerlink" title="第二章 操作系统介绍"></a>第二章 操作系统介绍</h1><p>程序运行时会发生什么：(冯诺依曼计算模型)<br>获取指令<code>fecth</code> -&gt; 解码指令<code>decode</code> -&gt; 执行指令<code>execute</code></p>
<p>操作系统主要利用一种通用的技术，我们称之为虚拟化（virtualization）。也就是说，操作系统将物理（physical）资源（如处理器、内存或磁盘）转换为更通用、更强大且更易于使用的虚拟形式。</p>
<p>为了让用户可以告诉操作系统做什么，从而利用虚拟机的功能（如运行程序、分配内存或访问文件），操作系统还提供了一些接口（API）。</p>
<blockquote>
<p>总的来说操作系统对下屏蔽底层硬件细节，对上提供接口调用底层硬件。让程序运行变得容易（甚至允许你同时运行多个程序），允许程序共享内存，让程序能够与设备交互，以及其他类似的有趣的工作。</p>
</blockquote>
<h2 id="虚拟化CPU"><a href="#虚拟化CPU" class="headerlink" title="虚拟化CPU"></a>虚拟化CPU</h2><p>此处主要说明了操作系统对于CPU的虚拟化能力，对单核CPU的串行调度。</p>
<blockquote>
<p>这里书中有一个例子展示了虚拟化CPU，操作系统在单CPU设备上调度多个进程。</p>
</blockquote>
<h2 id="虚拟化内存"><a href="#虚拟化内存" class="headerlink" title="虚拟化内存"></a>虚拟化内存</h2><p>多进程通过虚拟内存共享物理内存</p>
<blockquote>
<p>例子展示了多进程共享相同的内存地址，就好像每个进程都有自己的私有内存。（展示这里例子要关闭进程地址随机化，参数是<code>/proc/sys/kernel/randomize_va_space</code>）</p>
</blockquote>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>简单来说就是通过多线程之间的共享变量，会对非原子操作有影响。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../include/common_threads.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// volatile 标志这个变量可能不仅有当前程序改变，也可以被某些编译器未知的因素更改，比如操作系统、硬件或者其它线程等，添加该关键字后编译器将不对该变量优化，每次都是去内存里读</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实在这里加不加volatile都可以，主要是加了volatile很容易触发问题</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> loops;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">work</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;loops;i++) &#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: thread &lt;value&gt;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    loops = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> p1,p2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Initial value: %d\n&quot;</span>,counter);</span><br><span class="line"></span><br><span class="line">    Pthread_create(&amp;p1,<span class="literal">NULL</span>,work,<span class="literal">NULL</span>);</span><br><span class="line">    Pthread_create(&amp;p2,<span class="literal">NULL</span>,work,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    Pthread_join(p1,<span class="literal">NULL</span>);</span><br><span class="line">    Pthread_join(p2,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Final value : %d\n&quot;</span>,counter);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h2><p>介绍文件系统，性能优化，驱动等。</p>
<h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><p>它取得 CPU、内存或磁盘等物理资源（resources），甚对它们进行虚拟化（virtualize）。它处理与甚发（concurrency）有关的麻烦且棘手的问题。它持久地（persistently）存储文件，从而使它们长期随全。</p>
<ul>
<li>隔离</li>
<li>可靠性</li>
<li>安全性</li>
<li>移动性</li>
</ul>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用和过程调用之间的关键区别在于，系统调用将控制转移（跳转）到 OS 中，同时提高硬件特权级别（hardware privilege level）。用户应用程序以所谓的用户模式（user mode）运行，这意味着硬件限制了应用程序的功能。例如，以用户模式运行的应用程序通常不能发起对磁盘的I&#x2F;O 请求，不能访问任何物理内存页或在网络上发送数据包。在发起系统调用时通常通过一个称为陷阱（trap）的特殊硬件指令，硬件将控制转移到预先指定的陷阱处理程序（trap handler）（即预先设置的操作系统），甚同时将特权级别提升到内核模式（kernel mode）。在内核模式下，操作系统可以完全访问系统的硬件，因此可以执行诸如发起I&#x2F;O 请求或为程序提供更多内存等功能。当操作系统完成请求的服务时，它通过特殊的陷阱返回<br>（return-from-trap）指令将控制权交还给用户，该指令返回到用户模式，同时将控制权交还给应用程序，回到应用离开的地方。</p>
<hr>
<blockquote>
<p>后续简单介绍了操作系统的发展历史，这里就不再赘述了</p>
</blockquote>
<h1 id="第三章-关于虚拟化的对话"><a href="#第三章-关于虚拟化的对话" class="headerlink" title="第三章 关于虚拟化的对话"></a>第三章 关于虚拟化的对话</h1><blockquote>
<p>跳过</p>
</blockquote>
<h1 id="第4章-抽象：进程"><a href="#第4章-抽象：进程" class="headerlink" title="第4章 抽象：进程"></a>第4章 抽象：进程</h1><p>通过时分技术实现多进程共享CPU。</p>
<blockquote>
<p>操作系统会通过一系列的策略对进程占用时间片进行管理，同时对于硬件资源操作系统也会做相应的统一管理。</p>
</blockquote>
<h2 id="抽象：进程"><a href="#抽象：进程" class="headerlink" title="抽象：进程"></a>抽象：进程</h2><p>进程的机器状态：</p>
<ul>
<li>内存：指令和读取写入的数据都在内存里。</li>
<li>寄存器：用于读取存储指令，如程序计数器，栈指针和相关帧指针</li>
</ul>
<h2 id="进程API"><a href="#进程API" class="headerlink" title="进程API"></a>进程API</h2><p>操作系统必须以某种形式提供这些API：</p>
<ul>
<li>创建(create)</li>
<li>销毁(destory)</li>
<li>等待(wait)</li>
<li>其他控制(miscellaneous control)：除了杀死或等待，可能还要一些其他控制，例如暂停进程</li>
<li>状态(state)：提供当前进程的状态信息</li>
</ul>
<h2 id="进程创建：更多细节"><a href="#进程创建：更多细节" class="headerlink" title="进程创建：更多细节"></a>进程创建：更多细节</h2><p>操作系统是如何运行一个程序：</p>
<ol>
<li>将代码和静态数据（例如初始化变量）从硬盘加载到内存中，加载到进程的地址空间中。<br><img src="/2022/04/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/load_process.jpg"><blockquote>
<p>在早期的操作系统采用的加载方式是将进程一次性的加载到内存中，但是现代操作系统采用的加载方式是惰性加载，其实这里涉及到内存交换，内存虚拟化相应的知识。</p>
</blockquote>
</li>
<li>为程序运行时栈分配一些内存，用来存放局部变量，函数参数和返回值，实际上根据程序操作系统也会为程序的堆分配一些内存。</li>
<li>其他初始化工作如：I&#x2F;O初始化(Unix默认打开3个文件描述符)。<blockquote>
<p>这里涉及到I&#x2F;O和文件描述符的知识</p>
</blockquote>
</li>
<li>启动程序，OS将CPU的控制权转移到新创建的进程中</li>
</ol>
<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><ul>
<li>运行(runing)：进程正在处理器上运行，正在执行指令</li>
<li>就绪(ready)：就绪状态下，进程已准备好运行，但是由于某种原因操作系统不运行</li>
<li>阻塞(blocked)：一个进程执行了某种操作，知道发生其他事件才会准备运行，如：I&#x2F;O操作，他会被阻塞，其他进程可以使用CPU</li>
</ul>
<p><img src="/2022/04/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/process_state_machine.jpg"></p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>操作系统通过进程李彪来跟踪当前运行的进程，操作系统还必须以某种方式跟踪被阻塞的进程。</p>
<p>通过xv6进程数据结构：</p>
<blockquote>
<p>实际上xv6最新版本的代码和书上的代码有些出入，和书中一致的提交号为<code>943fd37</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Saved registers for kernel context switches.</span></span><br><span class="line"><span class="comment">// Don&#x27;t need to save all the %fs etc. segment registers,</span></span><br><span class="line"><span class="comment">// because they are constant across kernel contexts.</span></span><br><span class="line"><span class="comment">// Save all the regular registers so we don&#x27;t need to care</span></span><br><span class="line"><span class="comment">// which are caller save, but not the return register %eax.</span></span><br><span class="line"><span class="comment">// (Not saving %eax just simplifies the switching code.)</span></span><br><span class="line"><span class="comment">// The layout of context must match code in swtch.S.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> eip;</span><br><span class="line">  <span class="keyword">int</span> esp;</span><br><span class="line">  <span class="keyword">int</span> ebx;</span><br><span class="line">  <span class="keyword">int</span> ecx;</span><br><span class="line">  <span class="keyword">int</span> edx;</span><br><span class="line">  <span class="keyword">int</span> esi;</span><br><span class="line">  <span class="keyword">int</span> edi;</span><br><span class="line">  <span class="keyword">int</span> ebp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> &#123;</span> UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> *mem;                <span class="comment">// Start of process memory (kernel address)</span></span><br><span class="line">  uint sz;                  <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="keyword">char</span> *kstack;             <span class="comment">// Bottom of kernel stack for this process</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> <span class="title">state</span>;</span>    <span class="comment">// Process state</span></span><br><span class="line">  <span class="keyword">int</span> pid;                  <span class="comment">// Process ID</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>      <span class="comment">// Parent process</span></span><br><span class="line">  <span class="keyword">void</span> *chan;               <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="keyword">int</span> killed;               <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>        <span class="comment">// Current directory</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>   <span class="comment">// Switch here to run process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span>     <span class="comment">// Trap frame for current interrupt</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">16</span>];            <span class="comment">// Process name (debugging)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process memory is laid out contiguously, low addresses first:</span></span><br><span class="line"><span class="comment">//   text</span></span><br><span class="line"><span class="comment">//   original data and bss</span></span><br><span class="line"><span class="comment">//   fixed-size stack</span></span><br><span class="line"><span class="comment">//   expandable heap</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-CPU state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line">  uchar apicid;               <span class="comment">// Local APIC ID</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span>;</span>       <span class="comment">// Process currently running.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// Switch here to enter scheduler</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">taskstate</span> <span class="title">ts</span>;</span>        <span class="comment">// Used by x86 to find stack for interrupt</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">segdesc</span> <span class="title">gdt</span>[<span class="title">NSEGS</span>];</span>  <span class="comment">// x86 global descriptor table</span></span><br><span class="line">  <span class="keyword">volatile</span> uint booted;        <span class="comment">// Has the CPU started?</span></span><br><span class="line">  <span class="keyword">int</span> ncli;                   <span class="comment">// Depth of pushcli nesting.</span></span><br><span class="line">  <span class="keyword">int</span> intena;                 <span class="comment">// Were interrupts enabled before pushcli? </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="process-run-py"><a href="#process-run-py" class="headerlink" title="process-run.py"></a><code>process-run.py</code></h2><p>使用模拟器：<code>process-run.py</code><br>主要参数介绍：</p>
<ul>
<li>-l：x:y , x为需要执行的指令数，y为是cpu指令的几率，如果是100则是cpu指令，如果是0的话就是I&#x2F;O指令</li>
<li>-L：I&#x2F;O指令耗时</li>
<li>-S：进程切换特性，两个参数：SWITCH_ON_IO，SWITCH_ON_END</li>
<li>-I：I&#x2F;O处理特性，两个参数：IO_RUN_LATER，IO_RUN_IMMEDIATE</li>
<li>-c：计算答案</li>
<li>-p：打印数据统计</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>通过<code>scheduler.load()</code>载入指令，通过<code>scheduler.run()</code>对指令进行编排</p>
<blockquote>
<p>通过对指令排列进行模拟CPU行为</p>
</blockquote>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><h5 id="SWITH-ON-END"><a href="#SWITH-ON-END" class="headerlink" title="SWITH_ON_END"></a>SWITH_ON_END</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@giddypoet cpu-intro]# ./process-run.py -l 1:0,4:100 -c -p -S SWITCH_ON_END</span><br><span class="line">Time        PID: 0        PID: 1           CPU           IOs</span><br><span class="line">  1         RUN:io         READY             1          </span><br><span class="line">  2        WAITING         READY                           1</span><br><span class="line">  3        WAITING         READY                           1</span><br><span class="line">  4        WAITING         READY                           1</span><br><span class="line">  5        WAITING         READY                           1</span><br><span class="line">  6        WAITING         READY                           1</span><br><span class="line">  7*   RUN:io_done         READY             1          </span><br><span class="line">  8           DONE       RUN:cpu             1          </span><br><span class="line">  9           DONE       RUN:cpu             1          </span><br><span class="line"> 10           DONE       RUN:cpu             1          </span><br><span class="line"> 11           DONE       RUN:cpu             1          </span><br><span class="line"></span><br><span class="line">Stats: Total Time 11</span><br><span class="line">Stats: CPU Busy 6 (54.55%)</span><br><span class="line">Stats: IO Busy  5 (45.45%)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行I&#x2F;O时不切换</p>
</blockquote>
<h5 id="SWITCH-ON-IO"><a href="#SWITCH-ON-IO" class="headerlink" title="SWITCH_ON_IO"></a>SWITCH_ON_IO</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@giddypoet cpu-intro]# ./process-run.py -l 1:0,4:100 -c -p -S SWITCH_ON_IO</span><br><span class="line">Time        PID: 0        PID: 1           CPU           IOs</span><br><span class="line">  1         RUN:io         READY             1          </span><br><span class="line">  2        WAITING       RUN:cpu             1             1</span><br><span class="line">  3        WAITING       RUN:cpu             1             1</span><br><span class="line">  4        WAITING       RUN:cpu             1             1</span><br><span class="line">  5        WAITING       RUN:cpu             1             1</span><br><span class="line">  6        WAITING          DONE                           1</span><br><span class="line">  7*   RUN:io_done          DONE             1          </span><br><span class="line"></span><br><span class="line">Stats: Total Time 7</span><br><span class="line">Stats: CPU Busy 6 (85.71%)</span><br><span class="line">Stats: IO Busy  5 (71.43%)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行I&#x2F;O时切换</p>
</blockquote>
<h4 id="I-x2F-O切换"><a href="#I-x2F-O切换" class="headerlink" title="I&#x2F;O切换"></a>I&#x2F;O切换</h4><h5 id="IO-RUN-LATER"><a href="#IO-RUN-LATER" class="headerlink" title="IO_RUN_LATER"></a>IO_RUN_LATER</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@giddypoet cpu-intro]# ./process-run.py -l 2:0,6:100 -c -p -I IO_RUN_LATER</span><br><span class="line">Time        PID: 0        PID: 1           CPU           IOs</span><br><span class="line">  1         RUN:io         READY             1          </span><br><span class="line">  2        WAITING       RUN:cpu             1             1</span><br><span class="line">  3        WAITING       RUN:cpu             1             1</span><br><span class="line">  4        WAITING       RUN:cpu             1             1</span><br><span class="line">  5        WAITING       RUN:cpu             1             1</span><br><span class="line">  6        WAITING       RUN:cpu             1             1</span><br><span class="line">  7*         READY       RUN:cpu             1          </span><br><span class="line">  8    RUN:io_done          DONE             1          </span><br><span class="line">  9         RUN:io          DONE             1          </span><br><span class="line"> 10        WAITING          DONE                           1</span><br><span class="line"> 11        WAITING          DONE                           1</span><br><span class="line"> 12        WAITING          DONE                           1</span><br><span class="line"> 13        WAITING          DONE                           1</span><br><span class="line"> 14        WAITING          DONE                           1</span><br><span class="line"> 15*   RUN:io_done          DONE             1          </span><br><span class="line"></span><br><span class="line">Stats: Total Time 15</span><br><span class="line">Stats: CPU Busy 10 (66.67%)</span><br><span class="line">Stats: IO Busy  10 (66.67%)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>I&#x2F;O操作等待上一个cpu指令完成后才开始</p>
</blockquote>
<h5 id="IO-RUN-IMMEDIATE"><a href="#IO-RUN-IMMEDIATE" class="headerlink" title="IO_RUN_IMMEDIATE"></a>IO_RUN_IMMEDIATE</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@giddypoet cpu-intro]# ./process-run.py -l 2:0,6:100 -c -p -I IO_RUN_IMMEDIATE</span><br><span class="line">Time        PID: 0        PID: 1           CPU           IOs</span><br><span class="line">  1         RUN:io         READY             1          </span><br><span class="line">  2        WAITING       RUN:cpu             1             1</span><br><span class="line">  3        WAITING       RUN:cpu             1             1</span><br><span class="line">  4        WAITING       RUN:cpu             1             1</span><br><span class="line">  5        WAITING       RUN:cpu             1             1</span><br><span class="line">  6        WAITING       RUN:cpu             1             1</span><br><span class="line">  7*   RUN:io_done         READY             1          </span><br><span class="line">  8         RUN:io         READY             1          </span><br><span class="line">  9        WAITING       RUN:cpu             1             1</span><br><span class="line"> 10        WAITING          DONE                           1</span><br><span class="line"> 11        WAITING          DONE                           1</span><br><span class="line"> 12        WAITING          DONE                           1</span><br><span class="line"> 13        WAITING          DONE                           1</span><br><span class="line"> 14*   RUN:io_done          DONE             1          </span><br></pre></td></tr></table></figure>

<blockquote>
<p>I&#x2F;O指令立即开始，中断正在运行的cpu指令</p>
</blockquote>
<blockquote>
<p>两者的区别在于I&#x2F;O操作执行完是CPU先接受下一个I&#x2F;O请求，还是运行进程指令。由于采用默认模式SWITCH_ON_IO，CPU执行指令与I&#x2F;O操作同时进行，因而 IO_RUN_IMMEDIATE快一个单位时间。</p>
</blockquote>
<h2 id="第五章-插叙：进程API"><a href="#第五章-插叙：进程API" class="headerlink" title="第五章 插叙：进程API"></a>第五章 插叙：进程API</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><h3 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello from child %d\n&quot;</span>,getpid());</span><br><span class="line">        <span class="comment">//exit(0);</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        pid = wait(&amp;status);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent status %d (wait status %d),parent pid %d\n&quot;</span>, pid , status, getpid());</span><br><span class="line">        <span class="keyword">if</span>(WIFEXITED(status)) </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;exit code %d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">        <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;signal exit %d\n&quot;</span>, WSTOPSIG(status));</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;                                        </span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际上发现如果子进程没有指定退出时的返回值时，我当前环境返回的exit code不定</p>
</blockquote>
<blockquote>
<p>wait返回的是进程id，子进程调用wait后会立马返回，由于子进程没有子进程因此返回值为-1</p>
</blockquote>
<h3 id="exec系统调用"><a href="#exec系统调用" class="headerlink" title="exec系统调用"></a>exec系统调用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg,</span></span></span><br><span class="line"><span class="params"><span class="function">           ..., <span class="keyword">char</span> * <span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvpe</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[],</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>查找方式：带p的，表示可以通过环境变量查找响应的命令，可以只给出文件名，而不用给出完整的路径，不带p的则需要添加完整的路径</li>
<li>参数传递方式：带l表示逐个列举的形式，带v表示可以将所有参数构造成一个指针数组传递，首地址当做参数传递，数组中的最后一个指针要求是NULL</li>
<li>环境变量：exec函数族默认使用了系统默认的环境变量，也可以传入指定的环境变量，以e结尾的两个函数就可以在envp[]中指定当前进程使用的环境变量替换掉该进程所继承的所有环境变量</li>
</ul>
<p><img src="/2022/04/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/exec_faimly.jpg"></p>
<blockquote>
<p>实际上操作系统真正的系统调用只有execve，其他5个都是库函数，它们最终都会调用evecve这个系统调用<br>同时由于exec函数族替换了当前进程的堆栈信息，并替换成不同的程序，因此在exec函数族之后执行的代码通常不会执行，除非exec函数族执行失败。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果此时没有换行符，当前操作系统又是行缓冲，则有可能不会输出任何信息</span></span><br><span class="line">        <span class="comment">// printf(&quot;fork child \n&quot;);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork child \n&quot;</span>);</span><br><span class="line">        <span class="comment">// fflush(stdout);</span></span><br><span class="line">        close(STDOUT_FILENO);</span><br><span class="line">        open(<span class="string">&quot;./output.txt&quot;</span>,O_CREAT|O_WRONLY|O_TRUNC, S_IRWXU);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> * myargs[<span class="number">3</span>];</span><br><span class="line">        myargs[<span class="number">0</span>] = <span class="string">&quot;wc&quot;</span>;</span><br><span class="line">        myargs[<span class="number">1</span>] = <span class="string">&quot;wait.c&quot;</span>;</span><br><span class="line">        myargs[<span class="number">2</span>] = <span class="literal">NULL</span>;</span><br><span class="line">        execvp(myargs[<span class="number">0</span>],myargs);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">char</span> *myargs[<span class="number">3</span>];</span><br><span class="line">    myargs[<span class="number">0</span>] = <span class="string">&quot;/bin/ls&quot;</span>;</span><br><span class="line">    myargs[<span class="number">1</span>] = <span class="string">&quot;./&quot;</span>;</span><br><span class="line">    myargs[<span class="number">2</span>] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork error.\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// no.1</span></span><br><span class="line">        <span class="comment">// execl(&quot;/bin/ls&quot;,&quot;ls&quot;, &quot;./&quot;);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// no.2</span></span><br><span class="line">        <span class="comment">// execv(myargs[0],myargs);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// no.3</span></span><br><span class="line">        <span class="comment">// execlp(&quot;ls&quot;,&quot;ls&quot;,&quot;./&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// no.4</span></span><br><span class="line">        <span class="comment">// execvp(myargs[0],myargs);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// no.5</span></span><br><span class="line">        <span class="comment">// execle(&quot;/bin/ls&quot;,&quot;ls&quot;,&quot;./&quot;,NULL);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// no.6</span></span><br><span class="line">        execve(myargs[<span class="number">0</span>],myargs,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="vfork"><a href="#vfork" class="headerlink" title="vfork"></a>vfork</h3><p>vfork和fork之间的区别：</p>
<ul>
<li>fork本身父子进程的执行顺序不确定，但是vfork保证子进程先运行，再它调用exec或exit后父进程才能被调度。</li>
<li>同时fork创建的子进程是父进程的一个复制品，而vfork创建的子进程共享父进程的地址空间</li>
</ul>
<h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><blockquote>
<p>注意习题8中dup和pipe相关的函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dup是将oldfd复制给最小的未被使用的文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfd)</span></span>;</span><br><span class="line"><span class="comment">// dup2是将oldfd复制给newfd文件描述符，如果newfd存在，则将newfd先关闭，如果不存在直接复制</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd)</span></span>;</span><br><span class="line"><span class="comment">// pipe pipefd[0] read pipefd[1] write</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> pipefd[<span class="number">2</span>])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将管道连在一起的操作</span></span><br><span class="line">pipe(pipefd);</span><br><span class="line"><span class="comment">// clild fork 1</span></span><br><span class="line">dup2(pipefd[<span class="number">1</span>], STDOUT_FILENO);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line"><span class="comment">// child fork 2</span></span><br><span class="line">dup2(pipefd[<span class="number">0</span>], STDIN_FILENO);</span><br><span class="line">gets(buf);</span><br><span class="line"><span class="built_in">puts</span>(buf);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="第6章-机制：受限直接执行"><a href="#第6章-机制：受限直接执行" class="headerlink" title="第6章 机制：受限直接执行"></a>第6章 机制：受限直接执行</h2><p>虚拟化CPU支持多任务共享物理CPU，通过时分共享CPU，实现CPU虚拟化，因此引入了如下问题：</p>
<ul>
<li>性能，如何不增加系统开销实现虚拟化</li>
<li>控制权，有效地运行进程，同时保留对CPU的控制</li>
</ul>
<blockquote>
<p>简单来说就是如何高效、可控地虚拟化CPU</p>
</blockquote>
<p>为了限制进程的操作，演化出了用户模式和内核模式：</p>
<ul>
<li>用户模式，代码受限，不能直接访问I&#x2F;O</li>
<li>内核模式，代码可以执行它喜欢做的事，包括特权操作</li>
</ul>
<p>简单来说就是通过trap和return from trap实现的系统返回。</p>
<p>用户态内核切换：</p>
<ul>
<li>系统调用</li>
<li>Page fault， 运算时除以0的错误</li>
<li>一个设备触发了中断使得当前程序运行需要响应内核设备驱动</li>
</ul>
<blockquote>
<p>上述切换中，只有1和2涉及到trap的范畴，而3是一个中断的典型例子</p>
</blockquote>
<h3 id="trap"><a href="#trap" class="headerlink" title="trap"></a>trap</h3><p>在遇到trap时，操作系统通常会执行如下操作：</p>
<ol>
<li>先保护现场，保存当前32个用户寄存器，保存pc，用于从内核态返回后，继续执行用户态程序（这些寄存器设计多种功能，有为保存用户进程状态，有为trap提供工作基础等）</li>
<li>进入内核态，从user mode修改为supervisor mode，将SATP指向内核对应的页表</li>
</ol>
<blockquote>
<p>trap table以及userrecv等相关信息需要后续学习</p>
</blockquote>
<h3 id="在进程间切换"><a href="#在进程间切换" class="headerlink" title="在进程间切换"></a>在进程间切换</h3><h4 id="协作方式：等待系统调用"><a href="#协作方式：等待系统调用" class="headerlink" title="协作方式：等待系统调用"></a>协作方式：等待系统调用</h4><p>在这种模式下操作系统认为系统进程会合理的运行，运行时间过长的进程被假定会定期放弃CPU，以便操作系统能够决定运行其他任务。</p>
<ul>
<li>通过系统调用或者触发非法操作，将CPU的控制权交给操作系统。</li>
</ul>
<blockquote>
<p>实际上这个方式已经被遗弃，如果某个进程进入无线循环，并且从来不进行调用，会导致操作系统不能获取到CPU的控制权</p>
</blockquote>
<h4 id="非协作方式"><a href="#非协作方式" class="headerlink" title="非协作方式"></a>非协作方式</h4><p>没有硬件的额外帮助下，在上述方式下无法打断一个从来不进行系统调用的无限循环进程，因此需要借助外部设备来实现操作系统重新获取CPU控制权。</p>
<ul>
<li>利用时钟中断重新获取控制权，操作系统通过预先配置的时钟中断程序，重新获取CPU的控制权，来进行进程间的切换。</li>
</ul>
<h4 id="恢复和保存上下文"><a href="#恢复和保存上下文" class="headerlink" title="恢复和保存上下文"></a>恢复和保存上下文</h4><p>操作系统进程调度机制是有调度程序(scheduler)做出的，它是操作系统的一部分。</p>
<p>如果决定进行切换，OS就会执行一些底层代码，即所谓的上下文切换，上下文切换做的操作：</p>
<ul>
<li>操作系统为当前正在执行的进程保存一些寄存器的值，到它的内核栈中</li>
<li>同时将要执行的进程恢复一些寄存器的值</li>
</ul>
<blockquote>
<p>实际上操作系统会执行一些底层的汇编代码来保存和恢复通用寄存器、程序计数器，完成这一系列的操作后从陷阱返回指令时，就会将执行的进程变成当前进行的进程。</p>
</blockquote>
<h3 id="作业测量"><a href="#作业测量" class="headerlink" title="作业测量"></a>作业测量</h3><blockquote>
<p>通过sched_setaffinity实现将进程绑定到cpu核上，测试进程间切换，通过管道时间进程间的通信，用通信时间差值算出上下文切换花费的时间</p>
</blockquote>
<h2 id="第7章-进程调度：介绍"><a href="#第7章-进程调度：介绍" class="headerlink" title="第7章 进程调度：介绍"></a>第7章 进程调度：介绍</h2><h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><p>优势：<br>简单易于实现，在进程工作大致相同的时间是，可以完成。</p>
<p>劣势：<br>当某一个进程执行时间过长，导致系统的平均周转时间过长。</p>
<h3 id="SJF（最短任务优先）"><a href="#SJF（最短任务优先）" class="headerlink" title="SJF（最短任务优先）"></a>SJF（最短任务优先）</h3><p>在非抢占式模式下，实际上无法解决护航问题，同时最短任务只在理论上可信，实际工程场景中无法区分最短任务。</p>
<h3 id="STCF（最短完成时间优先）"><a href="#STCF（最短完成时间优先）" class="headerlink" title="STCF（最短完成时间优先）"></a>STCF（最短完成时间优先）</h3><p>在SJF上叠加抢占，称为最短完成时间优先。每当新的工作进入系统时，它就会确定剩余工作和新工作中，谁的剩余时间更少，然后调度该工作。</p>
<h3 id="新度量指标：响应时间"><a href="#新度量指标：响应时间" class="headerlink" title="新度量指标：响应时间"></a>新度量指标：响应时间</h3><p>首次运行时间 - 到达时间 &#x3D; 响应时间</p>
<h3 id="轮转"><a href="#轮转" class="headerlink" title="轮转"></a>轮转</h3><p>为程序分配不同的时间片，在不同的时间片运行不同的工作。</p>
<p>系统设计者需要权衡时间片长度，通过将时间片分给不同的工作，使其足够长，以便摊销上下文切换成本，并且不会使系统不及时响应。</p>
<blockquote>
<p>实际上要减少上下文切换在进程执行中所占用的时间，需要对时间片的长度进行考量<br>同时上下文件切换将带来大量的性能成本，CPU高速缓存、TLB、分支预测和其他片上硬件建立大量的状态，切换后导致明显的性能成本。</p>
</blockquote>
<h3 id="结合I-x2F-O"><a href="#结合I-x2F-O" class="headerlink" title="结合I&#x2F;O"></a>结合I&#x2F;O</h3><blockquote>
<p>简单来说在执行I&#x2F;O的时候CPU由其他工作抢占，等I&#x2F;O完成后，触发中断，CPU回到之前的工作。</p>
</blockquote>
<h2 id="第8章-调度：多级反馈队列"><a href="#第8章-调度：多级反馈队列" class="headerlink" title="第8章 调度：多级反馈队列"></a>第8章 调度：多级反馈队列</h2><h3 id="MLFQ：基本规则"><a href="#MLFQ：基本规则" class="headerlink" title="MLFQ：基本规则"></a>MLFQ：基本规则</h3><ul>
<li>通过多个队列区分不同的优先级，任何时刻一个工作只能存在一个队列中，MLFQ总是优先执行较高优先级的工作。</li>
<li>每个队列中可能有多个工作，同样的优先级下，对这些队列采用轮转调度</li>
</ul>
<blockquote>
<p>MLFQ核心问题在于如何设置优先级，MLFQ会根据进程行为学习其行为，预测动态调整其优先级</p>
</blockquote>
<h3 id="如何改变优先级"><a href="#如何改变优先级" class="headerlink" title="如何改变优先级"></a>如何改变优先级</h3>
	
	</div>
  <a type="button" href="/2022/04/18/操作系统导论/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/04/12/计算机是怎样跑起来的/" >计算机是怎样跑起来的</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-04-12  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<blockquote>
<p>&lt;&lt;计算机是怎么跑起来的&gt;&gt; 读书笔记</p>
</blockquote>
<h1 id="计算机三大原则"><a href="#计算机三大原则" class="headerlink" title="计算机三大原则"></a>计算机三大原则</h1><h2 id="计算机的三个根本性基础"><a href="#计算机的三个根本性基础" class="headerlink" title="计算机的三个根本性基础"></a>计算机的三个根本性基础</h2><ol>
<li>计算机是执行输入、运算、输出的机器</li>
<li>程序是指令和数据的集合</li>
<li>计算机的处理方式与人们的思维习惯不同</li>
</ol>
<h2 id="输入、运算、输出是硬件的基础"><a href="#输入、运算、输出是硬件的基础" class="headerlink" title="输入、运算、输出是硬件的基础"></a>输入、运算、输出是硬件的基础</h2><p>计算机是执行输入、运算、输出三种操作的机器。IC电路引脚也是围绕这个点进行设计的。</p>
<h2 id="软件是指令和数据的集合"><a href="#软件是指令和数据的集合" class="headerlink" title="软件是指令和数据的集合"></a>软件是指令和数据的集合</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump xxx</span><br></pre></td></tr></table></figure>

<h2 id="对计算机来说什么都是数字"><a href="#对计算机来说什么都是数字" class="headerlink" title="对计算机来说什么都是数字"></a>对计算机来说什么都是数字</h2><blockquote>
<p>这一章围绕作者提出的计算机的三个根本性基础，举例阐述佐证了作者的观点。</p>
</blockquote>
<h1 id="试着制造一台计算机吧"><a href="#试着制造一台计算机吧" class="headerlink" title="试着制造一台计算机吧"></a>试着制造一台计算机吧</h1><h2 id="制作微型计算机所必需的元件"><a href="#制作微型计算机所必需的元件" class="headerlink" title="制作微型计算机所必需的元件"></a>制作微型计算机所必需的元件</h2><p>基础元件：</p>
<ol>
<li>cpu：解释、执行程序（文中采用的是Z80 CPU）</li>
<li>内存：存储程序和数据（文中采用的是TC5517）</li>
<li>I&#x2F;O：连接外部设备（文中采用的是Z80 PIO）</li>
</ol>
<p>为了驱动CPU运转，时钟信号必不可少，通过高低电平切换，驱动CPU操作。简单来说时钟信号用于同步操作。</p>
<blockquote>
<p>下述其实是D触发器，当CLK为高电平的时候，当clk是1的时候，D的值就会被写进去，然后clk&#x3D;0的时候，Q就会一直是之前那个D，clk是0的时候，D的值再变，Q也不会变。为什么需要clk呢，因为你的设计里面，这个寄存器在等上一个寄存器的数据，你不知道上一个寄存器的数据存好了没，是新的还是旧的，你要写进去的数据写好了没。如果每个寄存器都用不同的clk，这样设计很容易不同步async，就是我想同时写几个register，但是这个register已经写完了，那个我不知道他存好了没，全局的clk能帮助解决很多这类问题。这个clk很大程度上左右了设计里面很多东西的读写速度。</p>
</blockquote>
<blockquote>
<p>当然，实际上的设计一般clk还会AND 一个叫enable的输入，那么当enable是0的时候，clk那边就一直是0，你要写进去这个flipflop，就需要enable&#x3D;1，clk&#x3D;1，这时候D就被存进去了。</p>
</blockquote>
<p><img src="/2022/04/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/register.png"></p>
<p>输入程序的装置也是必不可少的，通过拨动指拨开关来输入程序，8个开关作为输入元件，输出元件是8个LED。</p>
<p>同时还有DMA，将输入输出直接写入内存当中。</p>
<blockquote>
<p>此章节主要介绍了计算机的组成，设计到一些嵌入式单片机的知识，未做详细的描述，将其略过。</p>
</blockquote>
<h1 id="体验一次手工汇编"><a href="#体验一次手工汇编" class="headerlink" title="体验一次手工汇编"></a>体验一次手工汇编</h1><p>实际上通过上述计算机输入的二进制序列，实现汇编指令，驱动CPU实现指令。</p>
<blockquote>
<p>这里不再赘述</p>
</blockquote>
<h1 id="程序像河水一样流动着"><a href="#程序像河水一样流动着" class="headerlink" title="程序像河水一样流动着"></a>程序像河水一样流动着</h1><h2 id="程序的流程分为三种"><a href="#程序的流程分为三种" class="headerlink" title="程序的流程分为三种"></a>程序的流程分为三种</h2><p>计算机的硬件系统由CPU、I&#x2F;O和内存三部分构成。内存中存储这程序，也就是指令和数据。CPU配合着时钟发生器的时钟信号，从内存中读出指令，然后再依次对其进行解释和执行。</p>
<p>CPU中有各种各样的各司其职的寄存器。其中有一个被称为PC（Program Counter，程序计数器）的寄存器，负责存储内存地址，该地址指向下一条即将执行的指令，每解释执行完一条指令，PC寄存器的值就会自动被更新为下一条指令的地址。</p>
<p><img src="/2022/04/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/pc_register.jpg"></p>
<p>实际上程序的流程总共有三种，由PC控制器控制：</p>
<ol>
<li>顺序执行</li>
<li>条件分支</li>
<li>循环</li>
</ol>
<h2 id="特殊的程序流程–中断处理"><a href="#特殊的程序流程–中断处理" class="headerlink" title="特殊的程序流程–中断处理"></a>特殊的程序流程–中断处理</h2><p>处理中断</p>
<hr>
<blockquote>
<p>该书后续的介绍都较为浅显，偏入门的知识介绍，暂时不在阅读</p>
</blockquote>

	
	</div>
  <a type="button" href="/2022/04/12/计算机是怎样跑起来的/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/04/10/dpdk深入浅出/" >dpdk深入浅出</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-04-10  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h1 id="第一章-认识DPDK"><a href="#第一章-认识DPDK" class="headerlink" title="第一章 认识DPDK"></a>第一章 认识DPDK</h1><h2 id="主流包处理硬件平台"><a href="#主流包处理硬件平台" class="headerlink" title="主流包处理硬件平台"></a>主流包处理硬件平台</h2><p>简单介绍了当前从互联网面临的挑战：<code>从计算密集型设备转换为IO密集型设备</code>，同时介绍了当前主流包处理的硬件平台，并对其在不同领域的优缺点做了阐述：</p>
<ol>
<li>硬件加速器：适用于功能固化，功能具有高性能低成本的特点</li>
<li>网络处理器：提供了包处理逻辑软件可编程的能力，在获得灵活性的同事兼顾了高性能的硬件包处理</li>
<li>多核处理器：更为复杂多变的高层包处理上拥有优势</li>
</ol>
<h3 id="硬件加速器"><a href="#硬件加速器" class="headerlink" title="硬件加速器"></a>硬件加速器</h3><p>ASIC和FPGA。</p>
<blockquote>
<p>涉及集成电路和嵌入式设备，这里不再赘述。</p>
</blockquote>
<h3 id="网络处理器"><a href="#网络处理器" class="headerlink" title="网络处理器"></a>网络处理器</h3><p>网络处理器(Network  Processer  Unit，NPU)是专门为处理数据包而设计的可编程通用处理器，采用多内核并行处理结构，其常被应用于通信领域的各种任务，比如包处理、协议分析、路由查找、声音&#x2F;数据<br>的汇聚、防火墙、QoS等。</p>
<h3 id="多核处理器"><a href="#多核处理器" class="headerlink" title="多核处理器"></a>多核处理器</h3><p>由当前CPU性能的扩展方式引入了SOC，同时简单介绍了当前主流厂商的多核处理器的SOC平台。</p>
<h2 id="初识DPDK"><a href="#初识DPDK" class="headerlink" title="初识DPDK"></a>初识DPDK</h2><h3 id="IA-intel-architecture-不适合进行数据包处理吗"><a href="#IA-intel-architecture-不适合进行数据包处理吗" class="headerlink" title="IA(intel architecture)不适合进行数据包处理吗"></a>IA(intel architecture)不适合进行数据包处理吗</h3><p>传统linux包处理流程:</p>
<ol>
<li>数据包到达网卡</li>
<li>网卡设备依据配置进行DMA操作，简单来说就是将网卡中的数据直接拷贝到内存中，避免cpu浪费大量的时间片用于数据拷贝。（其实总线上有一个总的DMA控制器用于做DMA操作，不仅网卡，同时硬盘等其他IO设备都要使用DMA控制器）</li>
<li>网卡发送中断，通知CPU。（此处还涉及多队列网卡，网卡不同的队列中断号不一样）</li>
<li>驱动软件填充读写缓冲区数据结构。</li>
<li>数据报文到达内核协议栈，进行高层处理。</li>
<li>如果最终应用在用户态，数据将从内核拷贝至用户态。（涉及零拷贝知识，mmap，sendfile等）</li>
<li>如果最终应用在内核态，在内核继续进行。</li>
</ol>
<p>影响收包性能的主要因素：</p>
<ol>
<li>cpu中断，频繁的上下文切换，导致性能低下</li>
<li>数据拷贝，从网卡拷贝到内核，从内核拷贝到用户态</li>
<li>操作系统调度线程切换，导致cache替换，线程在不同核之间频繁切换，核减线程导致cache miss和cache write back造成大量的性能损失。</li>
<li>内存页表查询，大量的IO操作会剧烈的增加内存的查找，导致性能下降。</li>
</ol>
<blockquote>
<p>上述流程会引发一个问题，即便通过DMA的形式，在IO密集型的设备上，依然会因为触发大量的中断引起大量的开销，导致系统无法承受，因此引入了NAPI机制，其策略是设定中断阈值，当网卡上的中断未超过阈值，则采用中断模式，如果中断超过阈值，则系统被中断唤醒后，尽量使用轮询的方式一次性处理多个数据包，直到网络再次空闲重新传入中断等待。</p>
</blockquote>
<blockquote>
<p>其实，在上述过程中，发现除了网卡频繁触发中断，影响包处理性能，同时在内核态和用户态之间频繁发生数据拷贝也会大大的影响包处理性能。</p>
</blockquote>
<blockquote>
<p>netmap内存映射网卡的<code>packet buffer</code>到用户态，实现了自己的收发报文的<code>circular ring</code>来对应网卡的<code>ring</code>。越过内核态。</p>
</blockquote>
<blockquote>
<p>cpu亲和性，通过CPU亲和性，将线程绑定到cpu单个核上执行，cache miss和cache write back问题。</p>
</blockquote>
<p>DPDK通过以下技术解决了上述问题：</p>
<ol>
<li>轮询替换中断，避免中断上下文切换的开销</li>
<li>用户态驱动，在这种工作方式中，规避了不必要的内存拷贝，又避免了系统调用。</li>
<li>亲和性与独占，dpdk工作在用户态，利用线程的CPU亲和绑定的方式，特定任务值在某个核上工作。好处是可避免线程在不同核间频繁切换，核间线程切换容易导致因cache miss和cache write back造成的大量性能损失。</li>
<li>降低内存开销，通过大页内存降低TLB miss，利用内存多通道的交错访问能够有效提高内存访问的有效带宽。</li>
</ol>
<h3 id="DPDK框架简介"><a href="#DPDK框架简介" class="headerlink" title="DPDK框架简介"></a>DPDK框架简介</h3><p><img src="/2022/04/10/dpdk%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/dpdk_arch.png"></p>
<ul>
<li>核心库<code>Core Libs</code>：提供系统抽象、大页内存、缓存池、定时器及无锁环等基础组件</li>
<li>PMD库：提供全用户态的驱动，以便通过轮询和线程绑定得到极高的网络吞吐，支持各种本地和虚拟网卡</li>
<li>Classify库：支持精确匹配(Exact Match)、最长匹配(LPM)和通配符匹配(ACL)，提供常用的包处理的查表操作</li>
<li>Qos库：提供网络服务质量相关组件，如限速(Meter)和调度(Sched)</li>
</ul>
<blockquote>
<p>上述是DPDK主要的库，其实还提供了一些对于运行频率调整(Power)，与<code>Linux Kernel Stack</code>建立快速通道的(KNI Kernel Network Interface)。而<code>Packet FrameWrok</code>和<code>DISTRIB</code>是为了搭建更为复杂的多核流水线处理模型提供了基础组件。</p>
</blockquote>
<h2 id="解读数据包处理能力"><a href="#解读数据包处理能力" class="headerlink" title="解读数据包处理能力"></a>解读数据包处理能力</h2><p>实际上以太网帧数据最小是64个字节，其中包括46个字节的数据部分，2个字节的协议类型，12个字节的目的mac地址和源mac地址，以及4个字节的校验和。每个以太网帧默认帧间距为12个字节，同时每个帧还有7个字节的前导，和一个自己的帧首定界，因此一个最小以太网帧为<code>46+2+12+4+12+7+1=84</code>个字节，672个bit。</p>
<p>因此10Gbit&#x2F;s的网卡最大理论帧转发率为<code>10*1000/640=14.88Mpps</code>，14.88兆个包每秒。</p>
<h2 id="探索IA处理器上最艰巨的任务"><a href="#探索IA处理器上最艰巨的任务" class="headerlink" title="探索IA处理器上最艰巨的任务"></a>探索IA处理器上最艰巨的任务</h2><p>DPDK通过一系列软件优化方法（大页利用，cache对齐，线程绑定，NUMA感知，内存通道交叉访问，无锁化数据结构，预取，SIMD指令利用等）利用IA平台硬件特性，提供完整的底层开发支持库。使得单核三层转发可以轻松地突破小包30Mpps，随着CPU封装的核数越来越多，支持的PCIe通道数越来越多，整系统的三层转发吞吐在2路CPU的Xeon E5-2658v3上可以达到300Mpps。</p>
<h2 id="软件包处理的潜力"><a href="#软件包处理的潜力" class="headerlink" title="软件包处理的潜力"></a>软件包处理的潜力</h2><p>主要介绍了DPDK的使用场景：</p>
<ol>
<li>加速网络节点，支持虚拟化部署</li>
<li>加速计算节点</li>
<li>加速存储节点</li>
</ol>
<blockquote>
<p>后续还介绍了一堆DPDK适用的场景，一大堆就不在此赘述了</p>
</blockquote>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ol>
<li>helloworld</li>
<li>skeleton</li>
<li>l3fwd</li>
</ol>
<h3 id="helloworld"><a href="#helloworld" class="headerlink" title="helloworld"></a>helloworld</h3><blockquote>
<p>ret &#x3D; runtime enviroment<br>eal &#x3D; enviroment abstraction layer<br>DPDK区分了主线程和从线程</p>
</blockquote>
<p>对调用函数进行简单的介绍</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rte_eal_init</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该函数主要是对DPDK基础运行环境进行设置，具体内容如下：</p>
<ol>
<li>配置初始化</li>
<li>内存初始化</li>
<li>内存池初始化</li>
<li>队列初始化</li>
<li>告警初始化</li>
<li>中断初始化</li>
<li>PCI初始化</li>
<li>定时器初始化</li>
<li>检测内存本地化(NUMA)</li>
<li>插件初始化</li>
<li>主线程初始化</li>
<li>轮询设备初始化</li>
<li>建立主从线程通道(通过管道)</li>
<li>将从线程设置在等待模式(<code>_mm_pause()</code>等待主线程分发任务)</li>
<li>PCI设备的探测和初始化</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RTE_LCORE_FOREACH_SLAVE(i)					\</span></span><br><span class="line"><span class="meta">	for (i = rte_get_next_lcore(-1, 1, 0);				\</span></span><br><span class="line"><span class="meta">	     i&lt;RTE_MAX_LCORE;						\</span></span><br><span class="line"><span class="meta">	     i = rte_get_next_lcore(i, 1, 0))</span></span><br></pre></td></tr></table></figure>

<p>遍历从线程，即逻辑线程。（逻辑核就是cpu当前的核数）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rte_eal_remote_launch</span><span class="params">(<span class="keyword">lcore_function_t</span> *f, <span class="keyword">void</span> *arg, <span class="keyword">unsigned</span> slave_id)</span></span>;</span><br></pre></td></tr></table></figure>

<p>主线程通过管道向从线程分发任务，将f作为函数指针传递给从线程，arg作为执行参数，在slave_id的逻辑线程上执行该函数。</p>
<blockquote>
<p>通过<code>lcore_config[RTE_MAX_LCORE]</code>数组和逻辑线程id确定管段，通过管道启动任务。</p>
</blockquote>
<p>后续任务就是简单的执行相关函数。</p>
<h3 id="Skeleton"><a href="#Skeleton" class="headerlink" title="Skeleton"></a>Skeleton</h3><p>这个示例简单说就是一个单核的转发程序，设计初衷是实现一个最简单的报文转发程序，对报文不做任何改动。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool</span> *<span class="title">mbuf_pool</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> nb_ports;</span><br><span class="line">	<span class="keyword">uint16_t</span> portid;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialize the Environment Abstraction Layer (EAL). */</span></span><br><span class="line">	<span class="keyword">int</span> ret = rte_eal_init(argc, argv);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		rte_exit(EXIT_FAILURE, <span class="string">&quot;Error with EAL initialization\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	argc -= ret;</span><br><span class="line">	argv += ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check that there is an even number of ports to send/receive on. */</span></span><br><span class="line">	nb_ports = rte_eth_dev_count_avail();</span><br><span class="line">	<span class="keyword">if</span> (nb_ports &lt; <span class="number">2</span> || (nb_ports &amp; <span class="number">1</span>))</span><br><span class="line">		rte_exit(EXIT_FAILURE, <span class="string">&quot;Error: number of ports must be even\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Creates a new mempool in memory to hold the mbufs. */</span></span><br><span class="line">	mbuf_pool = rte_pktmbuf_pool_create(<span class="string">&quot;MBUF_POOL&quot;</span>, NUM_MBUFS * nb_ports,</span><br><span class="line">		MBUF_CACHE_SIZE, <span class="number">0</span>, RTE_MBUF_DEFAULT_BUF_SIZE, rte_socket_id());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mbuf_pool == <span class="literal">NULL</span>)</span><br><span class="line">		rte_exit(EXIT_FAILURE, <span class="string">&quot;Cannot create mbuf pool\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialize all ports. */</span></span><br><span class="line">	RTE_ETH_FOREACH_DEV(portid)</span><br><span class="line">		<span class="keyword">if</span> (port_init(portid, mbuf_pool) != <span class="number">0</span>)</span><br><span class="line">			rte_exit(EXIT_FAILURE, <span class="string">&quot;Cannot init port %&quot;</span>PRIu16 <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">					portid);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rte_lcore_count() &gt; <span class="number">1</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\nWARNING: Too many lcores enabled. Only 1 used.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Call lcore_main on the master core only. */</span></span><br><span class="line">	lcore_main();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* clean up the EAL */</span></span><br><span class="line">	rte_eal_cleanup();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意其中采用了基于分支预测的&#96;likely和unlikely相关函数，这是一个性能优化的小技巧。要求编译的时候使用-O2的选项，否则优化不起作用。简单来说会将可能执行的机器码放在前面，提高cpu执行效率。</p>
</blockquote>
<ol>
<li>调用<code>rte_eal_init</code>初始化运行环境</li>
<li>分配内存池<code>rte_pktmbuf_pool_create</code>，此处调用了<code>rte_socket_id</code>保证访问的内存是近端的</li>
<li><code>port_init</code>初始化网口配置</li>
<li><code>lcore_main</code>进行主处理流程</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct rte_mempool *</span></span><br><span class="line"><span class="function"><span class="title">rte_pktmbuf_pool_create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">unsigned</span> <span class="keyword">int</span> n,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">unsigned</span> <span class="keyword">int</span> cache_size, <span class="keyword">uint16_t</span> priv_size, <span class="keyword">uint16_t</span> data_room_size,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> socket_id)</span></span>;</span><br></pre></td></tr></table></figure>
<p>内存池，这个mbuf pool主要是给网卡接收数据包提供mbuf的，当网卡通过DMA收到数据需要把数据包通过DMA传送到一块内存，正是这个mbuf pool中的内存。</p>
<ul>
<li>name：内存池名</li>
<li>n：mp里面obj的数量，在这里表示mbuf的数量，如果你的代码缓存mbuf比较多，这里就需要设置大一些，防止不够用</li>
<li>cache_size：mp里面cache的数量</li>
<li>priv_size：每一个mbuf私有数据空间的大小，不需要直接设置为0即可</li>
<li>data_room_size：mbuf的数据报文的大小，理论上需要加上room head的大小，建议使用默认值，默认2048+128 RTE_MBUF_DEFAULT_BUF_SIZE</li>
<li>socket_id：申请内存的socket，不清楚设置那个的直接使用rte_socket_id()即可</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">rte_eth_dev_configure</span><span class="params">(<span class="keyword">uint16_t</span> port_id, <span class="keyword">uint16_t</span> nb_rx_q, <span class="keyword">uint16_t</span> nb_tx_q,</span></span></span><br><span class="line"><span class="params"><span class="function">		      <span class="keyword">const</span> struct rte_eth_conf *dev_conf)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>port_id：设备的port_id</li>
<li>nb_rx_q：收队列数</li>
<li>nb_tx_q：发送队列数</li>
<li>dev_conf：设备相关信息，如收发模式和速率等</li>
</ul>
<blockquote>
<p>配置网卡，包括网卡收包大小，网卡队列，端口和队列关联</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">rte_eth_rx_queue_setup</span><span class="params">(<span class="keyword">uint16_t</span> port_id, <span class="keyword">uint16_t</span> rx_queue_id,</span></span></span><br><span class="line"><span class="params"><span class="function">		       <span class="keyword">uint16_t</span> nb_rx_desc, <span class="keyword">unsigned</span> <span class="keyword">int</span> socket_id,</span></span></span><br><span class="line"><span class="params"><span class="function">		       <span class="keyword">const</span> struct rte_eth_rxconf *rx_conf,</span></span></span><br><span class="line"><span class="params"><span class="function">		       struct rte_mempool *mp)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>port_id：设备的port_id</li>
<li>rx_queue_id：队列号，存在多个队列要每个都设置</li>
<li>nb_rx_desc：设置队列的接收描述符(desc)的个数，也决定这接收队列的大小</li>
<li>socket_id：numa架构下的socket id</li>
<li>rx_conf：接收配置文件，如释放和回写的阈值等，为NULL就采用默认配置文件。</li>
<li>rte_mempool：指向内存池的指针，从中分配网络内存缓冲区以填充接收环的每个描述符。</li>
</ul>
<blockquote>
<p>发送和接收一致</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint16_t</span></span></span><br><span class="line"><span class="function"><span class="title">rte_eth_rx_burst</span><span class="params">(<span class="keyword">uint16_t</span> port_id, <span class="keyword">uint16_t</span> queue_id,</span></span></span><br><span class="line"><span class="params"><span class="function">		 struct rte_mbuf **rx_pkts, <span class="keyword">const</span> <span class="keyword">uint16_t</span> nb_pkts)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint16_t</span></span></span><br><span class="line"><span class="function"><span class="title">rte_eth_tx_burst</span><span class="params">(<span class="keyword">uint16_t</span> port_id, <span class="keyword">uint16_t</span> queue_id,</span></span></span><br><span class="line"><span class="params"><span class="function">		 struct rte_mbuf **tx_pkts, <span class="keyword">const</span> <span class="keyword">uint16_t</span> nb_pkts)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>port_id：设备的port_id</li>
<li>queue_id：队列号</li>
<li>rx_pkts：指针数组的地址，指向包的地址,必须大于nb_pkts</li>
<li>nb_pkts：取回的数据包最大个数。该值必须可分解为8的倍数，以便与任何驱动程序合作。</li>
</ul>
<h3 id="l3fwd"><a href="#l3fwd" class="headerlink" title="l3fwd"></a>l3fwd</h3><h1 id="Cache和内存"><a href="#Cache和内存" class="headerlink" title="Cache和内存"></a>Cache和内存</h1><h2 id="存储系统简介"><a href="#存储系统简介" class="headerlink" title="存储系统简介"></a>存储系统简介</h2><p>存储系统：磁盘、磁带、光盘存储器、内存和CPU内部的Cache。</p>
<h3 id="系统架构演进"><a href="#系统架构演进" class="headerlink" title="系统架构演进"></a>系统架构演进</h3><p>早期的计算机，内存控制器还没有整合进 CPU，所有的内存访问都需要经过北桥芯片来完成。如下图所示，CPU 通过前端总线（FSB，Front Side Bus）连接到北桥芯片，然后北桥芯片连接到内存——内存控制器集成在北桥芯片里面。</p>
<p><img src="/2022/04/10/dpdk%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/cpu_fsb.jpg"></p>
<blockquote>
<p>这种架构下cpu无论访问内存，设备，同时处理器之间的交换都要通过北桥，北桥成为系统瓶颈</p>
</blockquote>
<p>实际上现在架构中，CPU中涵盖了内存控制器，因此CPU和内存就是直连的。</p>
<blockquote>
<p>CPU直连的设备通常有: PCIE、DRAM、QPI(numa架构下访问远端内存需要的，实际上QPI是FSB的一种替代方案，提供了更快的传输速率)</p>
</blockquote>
<p>但是这种架构不同cpu逻辑核访问的都是同一块内存，因此称为UMA(一致性内存访问)，总线模型保证了所有内存访问的都是一致的，不必考虑不同内存地址之间的差距。</p>
<blockquote>
<p>在这种场景下，提升性能的方案就是，提升CPU频率，DRAM频率，和”FSB”(QPI)总线的传输速率。实际上CPU主频已经存在物理瓶颈，无法再通过提升主频提升效率，后面就是开始堆核，然后开始多CPU插槽</p>
</blockquote>
<blockquote>
<p>作者注：dpdk涉及的知识体系庞大，深入理解dpdk的原理目前欠缺的知识体系较多，基础不牢地动山摇，只能一点点去补基础知识：1、计算机组成原理 （）2、操作系统 3、计算机系统基础 </p>
</blockquote>

	
	</div>
  <a type="button" href="/2022/04/10/dpdk深入浅出/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/03/25/mtu/" >mtu</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-03-25  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h1 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h1><p>Maximum Transmission Unit 最大传输单元。</p>
<p>不同链路介质对网络有不同的默认MTU值，以下是一些常见的默认值:</p>
<p><img src="/2022/03/25/mtu/frame_mtu.png"></p>
<p>以太网MTU通常被设置为1500。</p>
<h2 id="为什么以太网帧mtu被设为1500"><a href="#为什么以太网帧mtu被设为1500" class="headerlink" title="为什么以太网帧mtu被设为1500"></a>为什么以太网帧mtu被设为1500</h2><p>早期的以太网使用共享链路的工作方式，为了保证CSMA&#x2F;CD（载波多路复用&#x2F;冲突检测）机制，所以规定了以太帧长度最小为64字节，最大为1518字节。最小64字节是为了保证最极端的冲突能被检测到，64字节是能被检测到的最小值；最大不超过1518字节是为了防止过长的帧传输时间过长而占用共享链路太长时间导致其他业务阻塞。所以规定以太网帧大小为64~1518字节，虽然技术不断发展，但协议一直没有更改。</p>
<p>以太网最大的数据帧是1518字节，这样刨去帧头14字节和帧尾CRC校验部分4字节，那么剩下承载上层IP报文的地方最大就只有1500字节，这个值就是以太网的默认MTU值。这个MTU就是网络层协议非常关心的地方，因为网络层协议比如IP协议会根据这个值来决定是否把上层传下来的数据进行分片，如果单个IP报文长度大于MTU，则会在发送出接口前被分片，被切割为小于或等于MTU长度的IP包。</p>
<blockquote>
<p>其实不同厂商对于MTU的定义略有不同，常见的是MTU为IP包的最大长度，如cisco，MTU是指的IP+以太网帧头部，还有的MTU&#x3D;IP+以太网帧头部+CRC</p>
</blockquote>
<h2 id="MTU划分的帧格式"><a href="#MTU划分的帧格式" class="headerlink" title="MTU划分的帧格式"></a>MTU划分的帧格式</h2><p><img src="/2022/03/25/mtu/frame.png"></p>
<h2 id="Jumbo帧与MTU"><a href="#Jumbo帧与MTU" class="headerlink" title="Jumbo帧与MTU"></a>Jumbo帧与MTU</h2><blockquote>
<p>帧过小，导致帧的利用率过小，同时增加分片开销，帧过大，如果丢包导致大量数据重传浪费资源</p>
</blockquote>
<p>由于现在场景已由计算密集型转变为IO密集型，大量的网络数据需要进行分片，每个数据包都需要网络设备来进行处理，由此带来的额外开销也将很大，而且这个开销随着网络速度的提高而愈加明显。</p>
<p>于是一些厂商提出了巨型帧（Jumbo Frame）的概念，把以太网的最大帧长扩展到了9K，相当于增强版的MTU，区别在于：</p>
<ul>
<li>jumbo帧是在数据链路层处理的，MTU涉及的分片通常是在网络层进行的</li>
<li>jumbo帧包括二层以太网帧头和CRC部分，MTU一般不包括这部分，通常是指三层IP报文的长度。</li>
</ul>
<p>加大帧长的好处在于，减少了网络中数据包的个数，减轻了网络设备处理包头的额外开销。大量减少的帧数目也带来了性能的提高。</p>
<h2 id="TCP-MSS和MTU"><a href="#TCP-MSS和MTU" class="headerlink" title="TCP MSS和MTU"></a>TCP MSS和MTU</h2><p>TCP MSS（Maximum Segment Size）是指TCP协议所允许的从对方收到的最大报文长度，即TCP数据包每次能够传输的最大数据分段，只包含TCP Payload，不包含TCP Header和TCP Option。MSS是TCP用来限制application层最大的发送字节数。为了达到最佳的传输效能，TCP协议在建立连接的时候通常要协商双方的MSS值，这个值TCP协议在实现的时候往往根据MTU值来计算（需要减去IP包头20字节和TCP包头20字节），所以通常MSS为1460&#x3D;1500(MTU)- 20(IP Header) -20 (TCP Header)。</p>
<p><img src="/2022/03/25/mtu/mss.png"></p>
<h2 id="Path-MTU"><a href="#Path-MTU" class="headerlink" title="Path MTU"></a>Path MTU</h2><blockquote>
<p>简单来说就是路径上最小的MTU作为这条链路的MTU<br>路径MTU的探测，<br>UDP和TCP通过ICMP实现，ICMP会回复type为3code为4的差错报文，表示需要分片，但是IP包的DF已设置，导致报文不可达被丢弃，而在icmp回复的报文中会存在下一跳的的MTU值，即PATHMTUDiscovery。</p>
</blockquote>
<ol>
<li>如果主机本地链路的MTU大于端到端链路中某一点的MTU值，那么这个数据包因为有DF&#x3D;1的原因，会被丢弃。</li>
<li>如果路由器本地链路的MTU为整个端到端链路中最小值时，数据包很幸运的被送达目的地。</li>
</ol>
<p>对于1，路由器会回复icmp差错报文，同时在差错报文中携带了此路由器的下一跳MTU值。（Destination unreachable(fragmentation needed)），从而调整MTU值。</p>
<p><img src="/2022/03/25/mtu/PathMTU_Discovery.png"></p>
<blockquote>
<p>tcp协议栈会根据路由器回复的icmp报文动态调整mss，实际上处于安全考虑并不是所有的路由器都会回复icmp报文，如果此时没有收到任何icmp报文，tcp会在超时重传后修改mss的值为更小的值。上述的一切基于tcp开启mtu_probing实现</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 默认关闭</span></span><br><span class="line">[root@giddypoet ~]# cat /proc/sys/net/ipv4/tcp_mtu_probing </span><br><span class="line">0</span><br></pre></td></tr></table></figure>
	
	</div>
  <a type="button" href="/2022/03/25/mtu/#more" class="btn btn-default more">Read More</a>
</div>

		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">

   
    
           <a type="button" class="btn btn-default disabled"><i class="fa fa-arrow-circle-o-left"></i>Prev</a>
        

        <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
 
       <a href="/page/2/" type="button" class="btn btn-default ">Next<i class="fa fa-arrow-circle-o-right"></i></a>     
        

  
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			
  <div id="site_search">
   <div class="form-group">
    <input type="text" id="local-search-input" name="q" results="0" placeholder="Search" class="st-search-input st-default-search-input form-control"/>
   </div>  
  <div id="local-search-result"></div>
  </div>


		
			
	<div class="widget">
		<h4>Categories</h4>
		<ul class="tag_box inline list-unstyled">
		
			<li><a href="/categories/computer/">computer<span>1</span></a></li>
		
			<li><a href="/categories/dpdk/">dpdk<span>1</span></a></li>
		
			<li><a href="/categories/os/">os<span>15</span></a></li>
		
		</ul>
	</div>

		
			
	<div class="widget">
		<h4>Tag Cloud</h4>
		<ul class="tag_box inline list-unstyled">		
		
			<li><a href="/tags/computer/">computer<span>1</span></a></li>
		
			<li><a href="/tags/network/">network<span>14</span></a></li>
		
			<li><a href="/tags/os/">os<span>1</span></a></li>
		
			<li><a href="/tags/memory/">memory<span>1</span></a></li>
		
			<li><a href="/tags/dpdk/">dpdk<span>1</span></a></li>
		
		 
		</ul>
	</div>


		
			
<div class="widget">
  <h4>Recent Posts</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2022/07/26/拔网线tcp连接会发生什么/" ><i class="fa fa-file-o"></i>拔网线tcp连接会发生什么</a>
      </li>
    
      <li>
        <a href="/2022/07/19/wireguard/" ><i class="fa fa-file-o"></i>wireguard</a>
      </li>
    
      <li>
        <a href="/2022/07/08/raw-socket/" ><i class="fa fa-file-o"></i>raw_socket</a>
      </li>
    
      <li>
        <a href="/2022/06/24/ebpf/" ><i class="fa fa-file-o"></i>ebpf</a>
      </li>
    
      <li>
        <a href="/2022/06/24/xdp/" ><i class="fa fa-file-o"></i>xdp</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>Links</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-github"></i><a href="https://github.com/wzpan/hexo-theme-freemind" title="Freemind's Github repository." target="_blank">Freemind</a></li>
	
		<li><i class="fa fa-github"></i><a href="https://github.com/kristopolous/BOOTSTRA.386" title="BOOTSTRA.386's Github repository." target="_blank">BOOTSTRA.386</a></li>
	
		<li><i class="fa fa-github"></i><a href="https://github.com/blackshow/hexo-theme-freemind.386" title="Freemind.386's Github repository." target="_blank">Freemind.386</a></li>
	
		<li><i class="fa fa-github"></i><a href="http://www.github.com/GiddyPoet" title="My Github account." target="_blank">My Github</a></li>
	
	</ul>
</div>


		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->
	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2022 GiddyPoet
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a>,<a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>,<a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a> and <a href="http://getbootstrap.com/" target="_blank">BOOTSTRA.386</a>. 
     <br> Theme by <a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind.386</a>.    
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



</body>
   </html>
