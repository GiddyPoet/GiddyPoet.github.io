<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on GiddyPoet</title>
    <link>https://giddypoet.github.io/post/</link>
    <description>Recent content in Posts on GiddyPoet</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://giddypoet.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://giddypoet.github.io/post/my_first_blog/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://giddypoet.github.io/post/my_first_blog/</guid>
      <description> title: &amp;ldquo;My_first_blog&amp;rdquo; date: 2023-04-12T16:41:15+08:00 draft: true tcp_syncookies 背景 需要对设备进行synflood测试，验证syn_cookies功能是否正常。
syncookies原理 SYN Cookie是对TCP服务器端的三次握手做一些修改，专门用来防范SYN Flood攻击的一种手段。它的原理是，在TCP服务器接收到TCP SYN包并返回TCP SYN + ACK包时，不分配一个专门的数据区，而是根据这个SYN包计算出一个cookie值。这个cookie作为将要返回的SYN ACK包的初始序列号。
syncookies复用seqnum字段，前5个bits是简易版本的时间戳，中间3个bits是mss值，后面24个是散列值。
seqnum的构造
设t为一个缓慢增长的时间戳，前5个bits 设m为客户端发送的syn报文中的mss值，3个bits 设s是连接的元组信息（源IP，目的IP，源端口，目的端口）和t的hash值，即`s=hash(sip,dip,sport,dport,t)，s取低24位 当客户端收到携带这个seqnum的值，则会恢复ack报文，且报文中ack=n+1，那么在服务器收到它时，将ack-1即可拿到原始序列号，通过这种方式保存了syn报文的信息。
对ack报文检查
高5位表示的t与当前时间比较，看是否在时间范围内 将t和连接元组重新计算s，看是否和低24位一直，若不一致则说明报文被伪造 解析出其中的mss信息 syncookies的缺点 mss的编码只有3位，因此最多只有8种mss值 丢失大部分syn option（这里如果服务器和客户端都开起了时间戳ts，可以通过这ts里携带syn option，携带wscale，sack，ecn） 增加了hash运算的开销 syncookies的实现 linux内核实现syncookies的算法如下：
seq = hash(saddr, daddr, sport, dport, 0, 0) + req.th.seq + t &amp;lt;&amp;lt; 24 + (hash(saddr, daddr, sport, dport, t, 1) + mss_ind) &amp;amp; 0x00FFFFFF 内核相关配置 开启syncookies的条件是，设置了syncookies，并且在服务器的accept_queue满载时才会启用。
简单来说即便开启了syncookies，当accept_queue不满载的时候也不触发
那么这个accept_queue这个阈值是多少呢？这就涉及到linux的内核设计，linux将tcp连接分为两种：
全连接，ESTABLISHED的连接属于全连接，在全连接队列中 半连接，接收到syn包进入syn-recv状态后，即加入半连接队列 accept_queue即半连接队列。
# 半连接队列大小 [root@version ~]# cat /proc/sys/net/ipv4/tcp_max_syn_backlog 128 # syncookies开关 [root@version ~]# cat /proc/sys/net/ipv4/tcp_syncookies 1 </description>
      <content>&lt;hr&gt;
&lt;h2 id=&#34;draft-true&#34;&gt;title: &amp;ldquo;My_first_blog&amp;rdquo;
date: 2023-04-12T16:41:15+08:00
draft: true&lt;/h2&gt;
&lt;h1 id=&#34;tcp_syncookies&#34;&gt;tcp_syncookies&lt;/h1&gt;
&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;p&gt;需要对设备进行synflood测试，验证syn_cookies功能是否正常。&lt;/p&gt;
&lt;h2 id=&#34;syncookies原理&#34;&gt;syncookies原理&lt;/h2&gt;
&lt;p&gt;SYN Cookie是对TCP服务器端的三次握手做一些修改，专门用来防范SYN Flood攻击的一种手段。它的原理是，在TCP服务器接收到TCP SYN包并返回TCP SYN + ACK包时，不分配一个专门的数据区，而是根据这个SYN包计算出一个cookie值。这个cookie作为将要返回的SYN ACK包的初始序列号。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;syncookies复用seqnum字段，前5个bits是简易版本的时间戳，中间3个bits是mss值，后面24个是散列值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;seqnum的构造&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设t为一个缓慢增长的时间戳，前5个bits&lt;/li&gt;
&lt;li&gt;设m为客户端发送的syn报文中的mss值，3个bits&lt;/li&gt;
&lt;li&gt;设s是连接的元组信息（源IP，目的IP，源端口，目的端口）和t的hash值，即`s=hash(sip,dip,sport,dport,t)，s取低24位&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当客户端收到携带这个seqnum的值，则会恢复ack报文，且报文中ack=n+1，那么在服务器收到它时，将ack-1即可拿到原始序列号，通过这种方式保存了syn报文的信息。&lt;/p&gt;
&lt;p&gt;对ack报文检查&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高5位表示的t与当前时间比较，看是否在时间范围内&lt;/li&gt;
&lt;li&gt;将t和连接元组重新计算s，看是否和低24位一直，若不一致则说明报文被伪造&lt;/li&gt;
&lt;li&gt;解析出其中的mss信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;syncookies的缺点&#34;&gt;syncookies的缺点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;mss的编码只有3位，因此最多只有8种mss值&lt;/li&gt;
&lt;li&gt;丢失大部分syn option（这里如果服务器和客户端都开起了时间戳ts，可以通过这ts里携带syn option，携带wscale，sack，ecn）&lt;/li&gt;
&lt;li&gt;增加了hash运算的开销&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;syncookies的实现&#34;&gt;syncookies的实现&lt;/h3&gt;
&lt;p&gt;linux内核实现syncookies的算法如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;seq &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hash&lt;/span&gt;(saddr, daddr, sport, dport, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; req.th.seq &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; t &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;24&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;hash&lt;/span&gt;(saddr, daddr, sport, dport, t, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; mss_ind) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00FFFFFF&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;内核相关配置&#34;&gt;内核相关配置&lt;/h2&gt;
&lt;p&gt;开启syncookies的条件是，设置了syncookies，并且在服务器的accept_queue满载时才会启用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;简单来说即便开启了syncookies，当accept_queue不满载的时候也不触发&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么这个accept_queue这个阈值是多少呢？这就涉及到linux的内核设计，linux将tcp连接分为两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全连接，ESTABLISHED的连接属于全连接，在全连接队列中&lt;/li&gt;
&lt;li&gt;半连接，接收到syn包进入syn-recv状态后，即加入半连接队列&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;accept_queue即半连接队列。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 半连接队列大小&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;root@version ~&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# cat /proc/sys/net/ipv4/tcp_max_syn_backlog &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;128&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# syncookies开关&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;root@version ~&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# cat /proc/sys/net/ipv4/tcp_syncookies &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content>
    </item>
    
  </channel>
</rss>
